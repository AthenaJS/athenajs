{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 813088f9b5a1a4c4dc08","webpack:///./js/Core/Deferred.js","webpack:///./js/FX/FX.js","webpack:///./js/Map/Tile.js","webpack:///./js/Object/Behavior/Behavior.js","webpack:///./js/Object/Object.js","webpack:///./js/Audio/AudioManager.js","webpack:///./js/Resource/ResourceManager.js","webpack:///./js/Core/Dom.js","webpack:///./js/FX/Effect/Effect.js","webpack:///./js/Input/InputManager.js","webpack:///./js/Notification/NotificationManager.js","webpack:///./js/Binary/Binary.js","webpack:///./js/Object/Sprite.js","webpack:///./js/Object/Text.js","webpack:///./js/Core/Pool.js","webpack:///./js/Display/Display.js","webpack:///./js/Display/DisplayManager.js","webpack:///./js/FX/Easing/Easing.js","webpack:///./js/Map/Map.js","webpack:///./js/Map/MapEvent.js","webpack:///./js/Object/BitmapText.js","webpack:///./js/Object/Wave.js","webpack:///./js/athena-module.js","webpack:///./js/Core/Game.js","webpack:///./js/FX/Effect/Custom.js","webpack:///./js/FX/Effect/Fade.js","webpack:///./js/FX/Effect/Mosaic.js","webpack:///./js/FX/Effect/Rotate.js","webpack:///./js/Object/Behavior/Behaviors.js","webpack:///./js/Object/Behavior/GroundMove.js","webpack:///./js/Object/Behavior/InOut.js","webpack:///./js/Object/Behavior/Path.js","webpack:///./js/Object/Behavior/PlayerMove.js","webpack:///./js/Object/Behavior/SimpleFall.js","webpack:///./js/Object/Behavior/WeaponMove.js","webpack:///./js/Object/Circle.js","webpack:///./js/Object/Hud.js","webpack:///./js/Object/Menu.js","webpack:///./js/Scene/Scene.js","webpack:///./js/lib/fpscounter/fpscounter.min.js"],"names":["Deferred","promise","resolve","reject","effects","easing","FX","addEasing","t","fxName","fxClass","easingName","easingFn","instance","addFX","Tile","options","offsetX","offsetY","width","height","inertia","upCollide","downCollide","AIR","WALL","LADDER","Behavior","sprite","Input","gravity","vx","vy","checkWalls","checkFall","onVXChange","onVYChange","currentMap","mapEvent","GfxObject","type","id","objectId","Date","getTime","currentScene","_destroyed","children","wave","behavior","platform","collideGroup","canCollideFriendBullet","master","console","log","setBehavior","behaviorOptions","_settings","Object","assign","speed","visible","canCollide","plane","x","y","scale","angle","moving","data","path","target","targetOffsetX","targetOffsetY","spline","currentMovement","fxQueue","pool","reset","animate","name","scene","addObject","map","moveHandlers","savedX","savedY","forEach","child","setMap","setScene","_onMove","display","w","h","Behaviors","getBehavior","onMove","length","move","value","obj","hitBox","getHitBox","found","spriteHitBox","box","x2","y2","onCollision","max","i","hitTest","cb","push","args","callback","getEffect","fx","warn","setEasing","getEasing","start","then","setEndValue","fxObject","keys","stop","ctx","time","process","idx","indexOf","destroy","splice","destCtx","debug","error","panning","volume","opt","pan","loop","viewportX","viewportW","viewportY","viewportH","masterObject","sound","AM","play","image","strokeStyle","beginPath","moveTo","lineTo","closePath","stroke","freeFromPool","removeObject","audioCache","enabled","addSound","element","toggleSound","bool","err","instanceId","undefined","newObject","Obj","bind","apply","arguments","isLocal","document","location","href","match","scriptMaxTime","groupMaxTime","resources","def","loadedRes","numRes","res","progressCb","errorCb","dynamicScripts","iOS","navigator","userAgent","skipResources","async","loading","getResourceById","group","fullObject","rsGroup","rs","loaded","elt","resource","default","newResourceFromPool","createFromPool","Array","prototype","slice","call","concat","_createGroup","groupName","_groupExists","addResources","resGroup","constructor","JSON","parse","stringify","loadNextResource","_loadResource","loadResources","nextRes","size","gpTimeout","setTimeout","notLoaded","resId","state","src","getCanvasFromImage","canvas","createElement","naturalWidth","naturalHeight","getContext","drawImage","loadImage","gpName","img","Image","that","gp","onload","_resLoaded","createObjectPool","Pool","create","registerScript","poolSize","existing","loadScript","loadAudio","audio","Audio","onLoad","removeEventListener","preload","addEventListener","loadWadAudio","source","loadHowlerAudio","Howl","urls","loadJSON","fetch","response","status","json","newDef","loadMapData","Binary","getArrayBuffer","dataUrl","arrayBuffer","buffer","html","Math","floor","clearTimeout","Dom","selector","querySelectorAll","css","prop","val","node","style","appendTo","querySelector","appendChild","attr","att","setAttribute","addClass","classList","add","innerHTML","show","hide","Effect","context","startValue","endValue","duration","startTime","ended","stopped","fxCtx","currentTime","ellapsedTime","animProgress","PAD_BUTTONS","FACE_0","FACE_3","FACE_4","LEFT_SHOULDER","RIGHT_SHOULDER","LEFT_SHOULDER_BOTTOM","RIGHT_SHOULDER_BOTTOM","SELECT","START","LEFT_ANALOGUE_STICK","RIGHT_ANALOGUE_STICK","axes","gamepadSupport","recording","playingEvents","playingPos","recordedEvents","pad","keyPressed","padPressed","keyCb","gameRef","inputMode","dPadJoystick","jPollInterval","_init","_installInputModeSwitchHandler","_installKBEventHandlers","setInputMode","startRecordingEvents","stopRecordingEvents","playRecordedEvents","playPos","nextRecordedEvents","recordEvents","mode","setInterval","_pollJoystick","_clearJoystickPoll","_pollGamepad","_resetKeys","key","_pollNewGamepad","gamepads","getGamepads","webkitGetGamepads","webkitGamepads","item","buttons","pressed","_getModifiers","event","_initVirtualJoystick","fireJoystick","VirtualJoystick","container","body","limitStickTravel","mouseSupport","stickRadius","touch","changedTouches","pageX","window","innerWidth","clearInterval","down","up","joystick","fire","abs","deltaX","left","deltaY","keyCode","preventDefault","metas","running","getAllKeysStatus","result","array","getKeyStatus","installKeyCallback","removeKeyCallback","index","clearEvents","eventCallbacks","notify","eventType","params","listen","method","eventList","replace","split","sendArrayBufferView","view","url","req","XMLHttpRequest","open","send","responseType","Sprite","imageSrc","animations","load","currentAnim","currentFrame","currentFrameNum","previousFrameNum","currentAnimName","storedAnimName","storedFrameNum","numFrames","rewindOnEnd","direction","frameCounter","animEndDef","animChangeDef","rewinded","isDebug","frameDuration","frames","setImage","frameHeight","frameSpace","frameWidth","frameSpacing","anims","lastName","initProperties","animation","flipFrom","updateFlipAnimation","flipType","setAnimation","anim","animFromFrames","force","nextFrame","loopFrom","_animationEnded","rewind","animName","shiftX","shiftY","tilePos","tileWidth","currentWidth","getCurrentWidth","shift","fn","frameNum","revert","_animationChanged","onAnimationEnd","message","runPreviousEndMethod","func","oldAnim","advanceFrame","scaledW","getCurrentHeight","scaledH","subScaledW","subScaledH","getCurrentOffsetX","getCurrentOffsetY","drawX","getCurrentShiftX","drawY","getCurrentShiftY","mapOffsetX","mapOffsetY","isFxQueueEmpty","save","e","restore","showHitBox","executeFx","translate","rotate","draw","destX","destY","animationName","totalWidth","totalHeight","getElementById","webkitImageSmoothingEnabled","frame","lineCap","Text","fontFace","fontStyle","fontSize","fontWeight","align","color","_setFont","text","setText","fillStyle","font","textBaseline","fillText","_pool","_poolMarker","_poolSize","expandPool","newObj","_poolIndex","end","endIndex","Display","prefix","styles","getComputedStyle","documentElement","pre","join","OLink","dom","RegExp","lowercase","js","toUpperCase","substr","layers","numLayers","_createLayers","zIndex","clearRect","clearScreen","opacity","getOpacity","render","hudScene","oldStyle","when","post","clearAllScreens","DisplayManager","displays","Easing","b","c","d","cos","PI","maps","Map","tileHeight","tiles","_createTiles","triggers","windows","viewportTargetX","viewportTargetY","viewportSpeedX","viewsportSpeedY","viewportStartX","viewportStartY","viewportLimitX","viewportCenterX","viewportLimitY","viewportCenterY","scrollOffsetX","scrollOffsetY","scrollTileOffsetX","scrollTileOffsetY","viewportLimits","x1","y1","viewportLimitH","objects","friendBullets","enemies","platforms","_calcNumTiles","setBuffer","reverse","firstRow","lastRow","firstCol","lastCol","srcBitmap","startMoveTime","currentWindow","startX","startY","isDirty","displayed","trigerred","numViewportCols","numViewportRows","numCols","numRows","Uint8Array","tileTypes","RM","setMasterObject","moveProgress","viewportSpeedY","checkMasterPosition","checkForTriggers","movePlatforms","moveObjects","checkMasterToEnemiesCollisions","checkMasterBulletsToEnemiesCollisions","getTriggersForBox","trigger","triggered","handleEvent","savePosition","pos","getTilePos","TYPE","j","bullet","enemy","maxBullets","maxEnemies","object","platformBox","platformX","platformY","pos1","pos2","pos3","max1","max2","spriteYMax","minX","spriteXMax","minY","tileType","spaceX","spaceY","center","currentHitBox","hitObjectTest","centerXOverTile","types","tile","tileNum","useScrollOffset","currentTile","showHidden","_getBoundariesTiles","_getScrollOffset","drawTile","viewPortY","showTileBehaviors","addNewObjectsFromWindow","windowNum","items","spriteOptions","itemId","addItem","NM","gfxObject","foundIndex","spriteId","delay","waveSize","scheduleSprite","fill","bjects","tilesArray","tileDesc","itemBlocks","diffWidth","newWidth","diffHeight","newHeight","diffCols","diffRows","oldBlockX","oldBlockY","newBlockX","newBlockY","newBlocksX","newBlocksY","ArrayBuffer","num","MapEvent","switches","events","setSwitch","conditions","cond","success","getSwitch","toggleSwitch","checkConditions","setStartXYFromMaster","handleWave","getItem","targetId","BitmapText","pixelHeight","maxLines","charHeight","lineSpacing","scrolling","textArray","setFontParams","getBuffer","letterSpacing","charWidth","maxCharPerLine","maxPixels","bmStartX","bmStartY","setTextPosition","str","eof","line","getNextLineLength","scrollText","speedX","speedY","char","code","charCodeAt","offset","getCharOffset","drawLine","getLines","createBuffer","clearBuffer","renderText","copyHeight","copyStartY","showObjectBox","Wave","counter","afterDestroy","afterDestroyData","reward","itemType","Game","showFps","fpscounter","_initEvents","createDisplay","ResourceManager","timeout","animFrame","bindEvents","onEvent","AudioManager","addDisplay","autoStart","stopScene","setDisplay","clearDisplay","startScene","requestAnimationFrame","_renderSceneLoop","renderScene","run","_runSceneLoop","pause","unpause","cancelAnimationFrame","Custom","diff","Fade","startOpacity","endOpacity","currentOpacity","setOpacity","Mosaic","startWidth","ratio","Rotate","startAngle","endAngle","currentAngle","setAngle","behaviors","behaviorName","moveFn","inst","addBehavior","GroundMove","nextX","nextY","InOut","maxX","maxY","diffY","diffX","sign","NaN","Path","currentNode","nodes","dirX","dirY","numNodes","PlayerMove","startMovement","lookDirection","climbVY","jumping","firing","fromLadder","sideHit","LEFT","UP","startJump","walkLeft","RIGHT","walkRight","goUpOrClimb","DOWN","goDownOrClimb","idle","stopClimbing","CTRL","switchAbove","getMapEvent","handleAction","handleFire","jump","fall","canFire","previousMovement","storeCurrentAnim","restorePreviousAnim","charAt","startAnimation","fallTest","walk","readyToJump","ceil","horizTileHit","vertTileHit","noVx","noVy","stopAnimation","getSwitchAboveMaster","onlyClimb","climb","faceWall","goDown","SimpleFall","elasticity","onEnd","onGround","startVy","resetY","WeaponMove","Circle","radius","arc","Hud","score","alertnateScore","alternateScore","energy","$dest","info","inventory","defineProperty","get","set","drawBackground","Menu","title","selectedColor","menuItems","selectedItem","selectCallbacks","hoverCallbacks","itemHeight","addMenuItems","menu","menuItem","selectable","addMenuItem","active","nextItem","scenes","Scene","backgrounds","foregrounds","readyDef","pics","backgroundImage","playTime","_startCallbacks","_fillArrays","prepareCanvas","cacheImages","_getResourcesRef","_prepareCanvas","layerType","layerNum","layer","isArray","drawObjects","doNotResetMap","resume","moveSceneObjects","checkCollisions","drawMap","drawMapObjects","drawSceneObjects","global","globals","fpscounter_options","defaults","remove_on_click","canvas_w","canvas_h","ele","className","text_fps_x","text_fps_y","text_max_x","text_max_y","text_min_x","text_min_y","fps_font","min_max_font","gradient_fill","createLinearGradient","addColorStop","gradient_line","lineWidth","textContent","t_pre","t_now","u_pre","u_lim","h_arr","h_len","raf_request","raf_running","h_reduce","memo","checkfps","fps","c_min_max","c_min","c_max","c_delta","first_point","xy","now","min","round","unshift","pop","reduce","fps_val","fpsToPoint","delta","removeChild","auto_start"],"mappings":"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","file":"dist/athenajs.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AthenaJS\"] = factory();\n\telse\n\t\troot[\"AthenaJS\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 45);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 813088f9b5a1a4c4dc08","import Promise from 'es6-promise';\n\n/**\n * Simple wrapper for ES6 native Promise\n */\nexport default class Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/Core/Deferred.js","// import Mosaic from 'Mosaic';\nimport Fade from 'FX/Effect/Fade';\nimport Rotate from 'FX/Effect/Rotate';\nimport Custom from 'FX/Effect/Custom';\nimport Mosaic from 'FX/Effect/Mosaic';\n\n    /*jshint devel: true, bitwise: false*/\n    let effects = {},\n        easing = {};\n\n    class FX {\n        constructor() {\n            // by default, add linear easing, other easing are defined in Easing.js and may be added at runtime\n            this.addEasing('linear', (t) => t);\n        }\n        \n        addFX(fxName, fxClass) {\n            effects[fxName] = fxClass;\n        }\n\n        getEffect(fxName) {\n            return effects[fxName];\n        }\n\n        addEasing(easingName, easingFn) {\n            easing[easingName] = easingFn;\n        }\n\n        getEasing(easingName) {\n            return easing[easingName];\n        }\n    };\n\n    const instance = new FX();\n\n    instance.addFX('Mosaic', Mosaic);\n    instance.addFX('Fade', Fade);\n    instance.addFX('Rotate', Rotate);\n    instance.addFX('Custom', Custom);\n\n    export default instance;\n\n    \n\n\n// WEBPACK FOOTER //\n// ./js/FX/FX.js","\n\t/*jshint devel: true, bitwise: false*/\n\tclass Tile{\n\t\tconstructor(options) {\n\t\t\tthis.offsetX = options.offsetX || 0;\n\t\t\tthis.offsetY = options.offsetY || 0;\n\t\t\tthis.width = options.width || 0;\n\t\t\tthis.height = options.height || 0;\n\n\t\t\t// move\n\t\t\tthis.inertia = options.inertia || 1;\t\t\t// this is the inertia factor\n\t\t\tthis.upCollide = options.upCollide || true;\t\t// will object collide when dropping over this tile ?\n\t\t\tthis.downCollide = options.downCollide || true;\n\t\t}\n\n\t\tstatic get TYPE() {\n\t\t\treturn {\n\t\t\t\tAIR: 1,\n\t\t\t\tWALL: 2,\n\t\t\t\tLADDER: 3\n\t\t\t};\n\t\t}\n\t};\n\n\texport default Tile;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Map/Tile.js","    /*jshint devel: true, bitwise: false*/\n    /**\n     * Base class for behaviors.\n     * \n     * A behavior is a class that describes how a graphical object moves during the time.\n     * \n     * Every behavior should implement these two methods:\n     * \n     * - onMove()\n     * - getMapEvent()\n     * \n     * @param {Sprite} sprite The sprite to attach the behavior to.\n     * @param {InputManager} Input A reference to the InputManager.\n     * @param {Object} options An hash with behavior-specific properties.\n     * @param {Number} [options.gravity=0] The object's gravity.\n     * @param {Number} [options.vx=0] The object's horizontal velocity.\n     * @param {Number} [options.vy=0] The object's vertical velocity.\n     * @param {Function} [options.onVXChange=undefined] An optional callback to call when changing vx direction\n     * @param {Function} [options.onVYChange=undefined] An optional callback to call when changing vy direction\n     *\n     */\n    class Behavior {\n        constructor(sprite, Input, options) {\n            this.sprite = sprite;\n            this.Input = Input;\n            sprite.gravity = typeof options.gravity !== 'undefined' ? options.gravity : 0;\n            sprite.vx = typeof options.vx !== 'undefined' ? options.vx : 0;\n            sprite.vy = typeof options.vy !== 'undefined' ? options.vy : 0;\n            this.checkWalls = options.checkWalls || false;\n            this.checkFall = options.checkFall || false;\n\n            this.onVXChange = options.onVXChange || null;\n            this.onVYChange = options.onVYChange || null;\n        }\n\n        onMove(t) {\n            // does nothing\n        }\n\n        getMapEvent() {\n            return this.sprite.currentMap.mapEvent;\n        }\n    };\n\n    export default Behavior;\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/Behavior.js","import FX from 'FX/FX';\r\nimport Behaviors from 'Object/Behavior/Behaviors';\r\nimport Input from 'Input/InputManager';\r\nimport AM from 'Audio/AudioManager';\r\nimport Deferred from 'Core/Deferred';\r\n\r\n/*jshint devel: true, bitwise: false*/\r\n/*globals Class*/\r\n/**\r\n * `GfxObject` is the base class for objects that can be rendered on the screen.\r\n * \r\n * A `GfxObject` has properties like x, y, vx, vy, speed.\r\n * In order to be rendered, an object must be added onto the active scene/map.\r\n * It can also have an optional behavior which tells Athena how\r\n * to move an object at each frame.\r\n * \r\n * @param {string} type The type of object: this describes the type of object\r\n * @param {Object} options\r\n * @param {string} [options.objectId] The id of the object. The defaults is type + random timestamp.\r\n * @param {number} [options.collideGroup=0] The type of collision to use for the object.\r\n * @param {boolean} [options.master=false] Set to true if the object should be the master.\r\n * @param {boolean} [options.visible=true] An invisible object isn't rendered onto the screen.\r\n */\r\nclass GfxObject {\r\n  constructor(type, options) {\r\n    this.type = type;\r\n    this.id = options.objectId || (this.type + new Date().getTime());\r\n\r\n    this.currentMap = null;\r\n    this.currentScene = null;\r\n\r\n    // can be used to delay object destroy\r\n    this._destroyed = false;\r\n\r\n    this.children = [];\r\n\r\n    this.wave = options.wave || null;\r\n\r\n    this.behavior = null;\r\n\r\n    // is player on a platform ?\r\n    this.platform = null;\r\n\r\n    // 0 == master (player)\r\n    // 1 == enemies (inc. enemy bullets, gems, bonuses,...)\r\n    // 2 == friend bullets\r\n    this.collideGroup = options.collideGroup || 0;\r\n    this.canCollideFriendBullet = options.canCollideFriendBullet || false;\r\n\r\n    this.master = options.master || false;\r\n\r\n    if (options.behavior) {\r\n      console.log('need to set move to', options.behavior);\r\n      this.setBehavior(options.behavior, options.behaviorOptions);\r\n    }\r\n\r\n    // save settings for re-use\r\n    this._settings = Object.assign({\r\n      speed: 1,\r\n      visible: true,\r\n      canCollide: false,\r\n      plane: 0,\r\n      x: 0,\r\n      y: 0,\r\n      vx: 0,\r\n      vy: 0,\r\n      scale: 1.0,\r\n      angle: 0,\r\n      moving: true,\r\n      gravity: 0,\r\n      data: {},\r\n      path: null,\r\n      target: null,\r\n      targetOffsetX: 0,\r\n      targetOffsetY: 0,\r\n      wave: options.wave || null\r\n    }, options);\r\n    /*            {\r\n            speed: options.speed || 1,\r\n            visible: options.visible || true,\r\n            canCollide: options.canCollide || false,\r\n            plane: options.plane || 0,\r\n            x: options.x || 0,\r\n            y: options.y || 0,\r\n            scale: options.scale || 1.0,\r\n            angle: 0,\r\n            moving: typeof options.moving !== 'undefined' ? options.moving : true,\r\n            gravity: typeof options.gravity !== 'undefined' ? options.gravity : 0,\r\n            data: options.data || {},\r\n            path: null,\r\n                    target: options.target || null,\r\n                    targetOffsetX: options.targetOffsetX || 0,\r\n                    targetOffsetY: options.targetOffsetY || 0\r\n          };*/\r\n\r\n    // this._data = options.data || {};\r\n    // console.log('settings set', this._settings);\r\n\r\n    this.target = null;\r\n\r\n    this.spline = null;\r\n\r\n    this.currentMovement = '';\r\n\r\n    this.fxQueue = {};\r\n\r\n    if (!options.pool) {\r\n      // only set option if not from pool since pool elements are intantiated with\r\n      // fake data: we don't want to reset them yet\r\n      this.reset();\r\n\r\n      if (options.animate) {\r\n        this.animate(options.animate.name, options.animate.options);\r\n      }\r\n    }\r\n\r\n    if (options.scene) {\r\n      debugger;\r\n      options.scene.addObject(this);\r\n      return;\r\n    } else if (options.map) {\r\n      debugger;\r\n      return;\r\n      options.map.addObject(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the map, used when player lost for example.\r\n   * \r\n   * `speed`,  `visible`, `canCollide`, `plane`, `x`, `y`, `scale`, `angle`, `moving`,\r\n   * `vx` , `vy`, `gravity`, `wave`\r\n   * \r\n   */\r\n  reset() {\r\n    this.speed = this._settings.speed;\r\n    this.visible = this._settings.visible;\r\n    this.canCollide = this._settings.canCollide;\r\n    this.plane = this._settings.plane;\r\n    this.x = this._settings.x;\r\n    this.y = this._settings.y;\r\n    this.scale = this._settings.scale;\r\n    this.angle = this._settings.angle;\r\n    this.moving = this._settings.moving;\r\n\r\n    this.data = this._settings.data;\r\n\r\n    this.path = null;\r\n\r\n    this.vx = this._settings.vx || 0;\r\n    this.vy = this._settings.vy || 0;\r\n\r\n    this.gravity = this._settings.gravity;\r\n\r\n    // handlers\r\n    this.moveHandlers = [];\r\n\r\n    this.targetOffsetX = this._settings.targetOffsetX || 0;\r\n    this.targetOffsetY = this._settings.targetOffsetY || 0;\r\n    this.target = this._settings.target || null;\r\n\r\n    this.savedX = this.x;\r\n    this.savedY = this.y;\r\n\r\n    this.wave = this._settings.wave;\r\n  }\r\n\r\n  /**\r\n   * Sets the map of the object.\r\n   * \r\n   * @param {Map} map The map of the object.\r\n   * \r\n   * @note you don't usually need to call this method as it's called automatically when adding an object\r\n   * onto a map.\r\n   * \r\n   */\r\n  setMap(map) {\r\n    this.currentMap = map;\r\n\r\n    this.children.forEach((child) => {\r\n      child.setMap(map);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets the scene of the object.\r\n   * \r\n   * @param {Scene} scene The scene of the object.\r\n   * \r\n   * @note you don't usually need to call this method as it's called when adding an object onto a scene.\r\n   */\r\n  setScene(scene) {\r\n    this.currentScene = scene;\r\n\r\n    this.children.forEach((child) => {\r\n      child.setScene(scene);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * WIP Sets the platform of the object. This will be used when platforms will be fully implemented.\r\n   * \r\n   * @param {GfxObject} platform The platform the object is attached to.\r\n   */\r\n  setPlatform(platform) {\r\n    this.platform = platform;\r\n  }\r\n\r\n  /**\r\n   * Moves the object to a new destination.\r\n   * \r\n   * @param {number} The new horizontal position.\r\n   * @param {number} The new vertical position.\r\n   * \r\n   * @returns {GfxObject} this\r\n   */\r\n  moveTo(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this._onMove();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Centers the object into the scene.\r\n   * \r\n   * @returns {GfxObject} this\r\n   */\r\n  center() {\r\n    let display = this.currentScene.display;\r\n\r\n    this.x = (display.width - this.w) / 2;\r\n    this.y = (display.height - this.h) / 2;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets a new behavior to the object: this will be called in the move loop\r\n   * \r\n   * @param {String} name The name of the behavior to use.\r\n   * @param {Object} options The options of the behavior (may depend on the behavior type)\r\n   * \r\n   * @related {Behavior}\r\n   */\r\n  setBehavior(name, options) {\r\n    this.behavior = new (Behaviors.getBehavior(name))(this, Input, options);\r\n  }\r\n\r\n  /**\r\n   * You can call clearBehavior if you want to stop using a particular behavior.\r\n   * \r\n   * The vx and vy properties of the object will be set to zero.\r\n   */\r\n  clearBehavior() {\r\n    this.vx = this.vy = 0;\r\n    this.behavior = null;\r\n  }\r\n\r\n  /**\r\n   * Called on each move loop and used to move the object using its (optional) behavior or its\r\n   * vx and vy properties.\r\n   * \r\n   * @private\r\n   */\r\n  move() {\r\n    if (this.moving) {\r\n      if (!this.behavior) {\r\n        // TODO: check map to see if we can move\r\n        this.x += this.vx;\r\n        this.y += this.vy;\r\n\r\n        // gravity impacts velocity\r\n        this.vy -= this.gravity;\r\n      } else {\r\n        this.behavior.onMove();\r\n      }\r\n\r\n      if (this.children.length) {\r\n        this.children.forEach((child) => {\r\n          child.move();\r\n        });\r\n      }\r\n\r\n      // TODO: check map to see if we can move\r\n      /*                this.x += this.vx;\r\n                  this.y += this.vy;                */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Saves current object position into `savedX` and `savedY` properties\r\n   */\r\n  savePosition() {\r\n    this.savedX = this.x;\r\n    this.savedY = this.y;\r\n  }\r\n\r\n  /**\r\n   * Returns previously seved position\r\n   * \r\n   * @returns {Object} The saved position\r\n   */\r\n  getSavedPosition() {\r\n    return {\r\n      x: this.savedX,\r\n      y: this.savedY\r\n    };\r\n  }\r\n\r\n  /**\r\n   * NOT IMPLEMENTED\r\n   * \r\n   * @private\r\n   */\r\n  moveWithSpline(/*speed*/) {\r\n\r\n  }\r\n\r\n  /**\r\n   * Sets a new path for the object\r\n   * \r\n   * @param {Path} path The new path that the object will use when moving.\r\n   * \r\n   * @related {Path}\r\n   */\r\n  setPath(path) {\r\n    this.path = path;\r\n  }\r\n\r\n  /**\r\n   * Change the scale of the object\r\n   * \r\n   * @param {number} scale The new scale of the object.\r\n   * \r\n   * @note: it's only used when rendering, collision detection is not using the scale yet.\r\n   */\r\n  setScale(scale) {\r\n    this.scale = scale;\r\n  }\r\n\r\n  /**\r\n   * Change the angle of an object\r\n   * \r\n   * @param {number} angle The new angle of the object. 0 < angle < 360\r\n   * \r\n   * @note This property is only used for the rendering and it's ignored for collisions.\r\n   */\r\n  setAngle(angle) {\r\n    // this.angle = angle * Math.PI / 180;\r\n    this.angle = angle;\r\n  }\r\n\r\n  /**\r\n   * Returns the angle property of the object.\r\n   */\r\n  getAngle() {\r\n    return this.angle;\r\n    // return 180 * this.angle / Math.PI;\r\n  }\r\n\r\n  /**\r\n   * WIP Performs a transformation on the object\r\n   * \r\n   * @private\r\n   */\r\n  transform(type, value) {\r\n    switch (type) {\r\n      case 'scale':\r\n        this.scale = value;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hides the object\r\n   * \r\n   * @returns {GfxObject} this\r\n   */\r\n  hide() {\r\n    this.visible = false;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Show the object\r\n   * \r\n   * @returns {GfxObject} this\r\n   */\r\n  show() {\r\n    this.visible = true;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the current width of the object: with some types of GfxObjects ({Sprite}),\r\n   * width can vary\r\n   * \r\n   * @returns {number} The current width of the object\r\n   * \r\n   * @related {Sprite}\r\n   */\r\n  getCurrentWidth() {\r\n    return this.width;\r\n  }\r\n\r\n  /**\r\n   * Returns the current height of the object: with some types of GfxObjects ({Sprite}),\r\n   * height can vary\r\n   * \r\n   * @returns {number} The current height of the object\r\n   * \r\n   * @related {Sprite}\r\n   */\r\n  getCurrentHeight() {\r\n    return this.height;\r\n  }\r\n\r\n  // TODO: should return the type of sprite ?\r\n  // TODO: should check map ?\r\n  // TODO: handle scale/rotation here !!\r\n  /**\r\n   * Performs collision tests on the specifed object.\r\n   * \r\n   * @param {GfxObject} obj The object to perform test on\r\n   * \r\n   * @returns {Boolean} Returns true if this and obj collide\r\n   */\r\n  hitTest(obj) {\r\n    let hitBox = obj.getHitBox(),\r\n      found = false;\r\n\r\n    if (this.canCollide && obj.canCollide && this !== obj && this.visible) {\r\n      let spriteHitBox = this.getHitBox(),\r\n        box = {\r\n          x: this.x + spriteHitBox.x,\r\n          y: this.y + spriteHitBox.y,\r\n          x2: this.x + spriteHitBox.x + spriteHitBox.x2,\r\n          y2: this.y + spriteHitBox.y2 + spriteHitBox.y\r\n        };\r\n\r\n      if ((box.y < obj.y + hitBox.y && box.y2 > obj.y + hitBox.y) || (box.y > obj.y + hitBox.y && box.y < obj.y + hitBox.y + hitBox.y2)) {\r\n        if ((box.x < obj.x + hitBox.x && box.x2 > obj.x + hitBox.x) || (box.x > obj.x + hitBox.x && box.x < obj.x + hitBox.x + hitBox.x2)) {\r\n          // console.log('collision detected with', sprite.id);\r\n          obj.onCollision(this);\r\n          this.onCollision(obj);\r\n\r\n          found = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!found) {\r\n      let max = this.children.length,\r\n        i = 0;\r\n\r\n      while (!found && i < max) {\r\n        found = this.children[i].hitTest(obj);\r\n        i++;\r\n      }\r\n    }\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * WIP: Set a new target for the object\r\n   * \r\n   * It's planned to have the ability for objects to follow other objects, for example:\r\n   * homing missiles, etc...\r\n   * \r\n   * @private\r\n   */\r\n  setTarget(obj) {\r\n    this.target = obj;\r\n  }\r\n\r\n  /**\r\n   * Add a new handler to be called after each move of the object\r\n   * \r\n   * @param {Function} cb The callback to add\r\n   */\r\n  addMoveHandler(cb) {\r\n    this.moveHandlers.push(cb);\r\n  }\r\n\r\n  /**\r\n   * onHit is called when the object collides with another object\r\n   * \r\n   * @param {GfxObject} obj The object that collided.\r\n   * \r\n   * This function does nothing interesting: this should be extended if needed.\r\n   */\r\n  onHit(obj) {\r\n    console.log('[GfxObject] oops, ', this.type, ' [', this.id, '] ', 'was hit by', obj.name, ' [', obj.id, ']');\r\n  }\r\n\r\n  /**\r\n   * INTERNAL: calls move handles\r\n   * \r\n   * @private\r\n   */\r\n  _onMove() {\r\n    const args = [this.x, this.y];\r\n    this.moveHandlers.forEach((callback) => callback(...args));\r\n  }\r\n\r\n  /**\r\n   * INTERNAL: checks if object fx queue is empty\r\n   * \r\n   * @returns {Boolean} True if the queue is empty, false otherwise.\r\n   * \r\n   * @private\r\n   */\r\n  isFxQueueEmpty() {\r\n    for (var i in this.fxQueue) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Performs an animation on the object using one of the defined {FX} effects\r\n   * \r\n   * Effects change the object size/position using an interpolation function.\r\n   * \r\n   * Athena has the following effects:\r\n   * - {Fade} performs a fade\r\n   * - {Mosaic} performs a SNES-like mosaic effect\r\n   * - {Rotate} performs a rotation on the object\r\n   *\r\n   * @param {String} fxName the name of the effect to use.\r\n   * @param {Object} options the options of the effect.\r\n   * @param {String} [options.easing=\"linear\"] The easing functions to use, can be: 'linear', 'swing', 'easeInQuad', 'easeOutBounce'.\r\n   * \r\n   * @returns {Promise} a promise that will be fullfilled when the effect has been completed\r\n   */\r\n  animate(fxName, options) {\r\n    // console.log('animate');\r\n    let fxClass = FX.getEffect(fxName),\r\n      promise = new Deferred().resolve(),\r\n      easing = options.easing || 'linear',\r\n      fx;\r\n\r\n    if (typeof this.fxQueue[fxName] !== 'undefined') {\r\n      console.warn('Fx', fxName, 'already in progress, cannot execute twice');\r\n    } else if (!fxClass) {\r\n      console.warn('Fx', fxName, 'unknown: did you spell it correctly ?');\r\n    } else {\r\n      fx = new fxClass(options);\r\n      fx.setEasing(new FX.getEasing(easing));\r\n\r\n      promise = fx.start().then(() => {\r\n        // console.log('effect ended, need to stop it', fxName);\r\n        delete this.fxQueue[fxName];\r\n      });\r\n\r\n      this.fxQueue[fxName] = fx;\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Stop current running animation\r\n   * \r\n   * In some cases, the game may need to stop effects from running before\r\n   * they are completed. This method proves a way to do so and set an end value.\r\n   * \r\n   * @param {any} The end value of the animation\r\n   */\r\n  stopAnimate(setEndValue) {\r\n    let fxObject = null;\r\n\r\n    // console.log('need to stop animation');\r\n    Object.keys(this.fxQueue).forEach((fxName) => {\r\n      fxObject = this.fxQueue[fxName];\r\n\r\n      fxObject.stop(setEndValue);\r\n    });\r\n    // for (let fxName in this.fxQueue) {\r\n\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Perform each fx remaining in the fxQueue\r\n   * \r\n   * @param {CanvasContext} ctx Where to perform the rendering.\r\n   * @param {number} time The current time ellapsed since fx queue was started.\r\n   * \r\n   * @private\r\n   */\r\n  executeFx(ctx, time) {\r\n    let fxObject = null;\r\n\r\n    Object.keys(this.fxQueue).forEach((fxName) => {\r\n      fxObject = this.fxQueue[fxName];\r\n\r\n      fxObject.process(ctx, null, this, time);\r\n    });\r\n    // for (var fxName in this.fxQueue) {\r\n    //     fxObject = this.fxQueue[fxName];\r\n\r\n    //     fxObject.process(ctx, null, this, time);\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * onCollision is called on each collision with the object.\r\n   * \r\n   * This method does nothing and should be extended if needed.\r\n   * \r\n   */\r\n  onCollision() {\r\n    //console.log('onCollision does nothing by default');\r\n  }\r\n\r\n  /**\r\n   * Add a new Child to the object.\r\n   * \r\n   * Childs are automatically rendered and moved when the parent object is.\r\n   * \r\n   * @param {GfxObject} child The child to add.\r\n   * \r\n   * @note children are automatically added to the scene/map of the parent object.\r\n   */\r\n  addChild(child) {\r\n    child.setMap(this.currentMap);\r\n    child.setScene(this.currentScene);\r\n\r\n    this.children.push(child);\r\n  }\r\n\r\n  /**\r\n   * Remove a child from the object\r\n   * \r\n   * @param {GfxObject} child The child to remove from the object.\r\n   * \r\n   * @note: removing a child object will call its `destroy` method\r\n   */\r\n  removeChild(child) {\r\n    let idx = this.children.indexOf(child);\r\n\r\n    if (idx > -1) {\r\n      this.children[idx].destroy();\r\n      this.children.splice(idx, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove every children from the object\r\n   */\r\n  removeAllChildren() {\r\n    for (let i = 0; i < this.children.length; ++i) {\r\n      this.children[i].destroy();\r\n    }\r\n    this.children.length = 0;\r\n  }\r\n\r\n  /**\r\n   * This method is called when drawing an object\r\n   * \r\n   * GfxObject is a virtual object so its drawing method does nothing\r\n   * \r\n   * Every Object inheriting from GfxObject should implement its own draw method.\r\n   * \r\n   * @param {CanvasContext} destCtx the target canvas rendering context.\r\n   * @param {Boolean} debug Debug is set to true if the game is being debugged.\r\n   */\r\n  draw(destCtx, debug) {\r\n    console.error('[GfxObject] you need to define a draw method for your object, GfxObjects do not have a draw method');\r\n  }\r\n\r\n  /**\r\n   * Plays the spcified sound\r\n   * \r\n   * @param {String} id The id of the sound to play\r\n   * @param {Object} options\r\n   * @param {Boolean} [options.pan=true] Set pan to true if you want to use panning.\r\n   * @param {Boolean} [options.loop=false] Set to true to loop the sound.\r\n   */\r\n  playSound(id, options) {\r\n    let panning = 0,\r\n      map = this.currentMap,\r\n      volume = 1.0,\r\n      opt = options || {\r\n        pan: true,\r\n        loop: false\r\n      };\r\n\r\n    // volume: outside of screen = volume down\r\n    if (map && (this.x < -map.viewportX || this.x > -map.viewportX + map.viewportW) || (this.y < -map.viewportY || this.y > -map.viewportY + map.viewportH)) {\r\n      volume = 0.2;\r\n    }\r\n\r\n    // panning depends on player position\r\n    if (map && opt.pan) {\r\n      panning = this.x < map.masterObject.x ? -5 : 5;\r\n    }\r\n\r\n    this.sound = AM.play(id, opt.loop || false, volume, panning);\r\n  }\r\n\r\n  /**\r\n   * WIP\r\n   * \r\n   * @private\r\n   */\r\n  // does nothing by default, must be redefined if needed\r\n  setImage(image) {\r\n\r\n  }\r\n\r\n  /**\r\n   * Draws a box around objects. This method is called when debugging is enabled.\r\n   * \r\n   * @param {CanvasContext} ctx The context where to draw the box\r\n   */\r\n  showObjectBox(ctx) {\r\n    ctx.strokeStyle = 'rgb(0,230,0)';\r\n    ctx.beginPath();\r\n    ctx.moveTo(this.x, this.y);\r\n    ctx.lineTo(this.w + this.x, this.y);\r\n    ctx.lineTo(this.w + this.x, this.y + this.h);\r\n    ctx.lineTo(this.x, this.y + this.h);\r\n    ctx.lineTo(this.x, this.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n\r\n  // 1. remove from pool, if pooled object\r\n  // 2. remove from map or scene\r\n  /**\r\n   * Destroy is called when an object is removed from a scene or object\r\n   * \r\n   * @note calling destroy on a parent will automatically call the destroy method of each child.\r\n   */\r\n  destroy() {\r\n    this._destroyed = true;\r\n\r\n    if (typeof this.freeFromPool === 'function') {\r\n      this.freeFromPool();\r\n    }\r\n\r\n    if (this.currentMap) {\r\n      this.currentMap.removeObject(this);\r\n    } else if (this.currentScene) {\r\n      this.currentScene.removeObject(this);\r\n    }\r\n\r\n    this.children.forEach((child) => {\r\n      child.destroy();\r\n    });\r\n  }\r\n};\r\n\r\nexport default GfxObject;\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Object.js","       /*jshint devel: true*/\r\n        /**\r\n         * `AudioManager` handles playback of audio files loaded using the `ResourceManager`\r\n         * \r\n         * @property {Object} audioCache An hash that stores in-use sounds.\r\n         * The key is the id of the sound.\r\n         * @property {boolean} enabled This is set to false when sound playback is disabled.\r\n         */\r\n        export default {\r\n            audioCache: {},\r\n            enabled: true,\r\n            /**\r\n             * Adds a new sound element to the audio cache.\r\n             * *Note* if a sound with the same id has already been added, it will be replaced\r\n             * by the new one.\r\n             * \r\n             * @param {String} id\r\n             * @param {HTMLAudioElement} element\r\n             */\r\n            addSound: function (id, element) {\r\n                this.audioCache[id] = element;\r\n            },\r\n            /**\r\n             * Toggles global sound playback\r\n             * \r\n             * @param {Boolean} bool whether to enabled or disable sound playback.\r\n             */\r\n            toggleSound: function (bool) {\r\n                this.enabled = bool;\r\n            },\r\n            /**\r\n             * Plays the specified sound with `id`.\r\n             * \r\n             * @param {String} id\r\n             * @param {Boolean} loop\r\n             * @param {Float} volume\r\n             * @param {Float} panning\r\n             * @returns the created sound instance\r\n             */\r\n            play: function (id, loop, volume, panning) {\r\n                let instance = null,\r\n                    sound = null;\r\n\r\n                if (!this.enabled) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    sound = this.audioCache[id];\r\n                } catch (err) {\r\n                    console.warn('[AM] WARN: unable to play sound', id);\r\n                    return;\r\n                }\r\n\r\n                if (typeof sound === 'undefined') {\r\n                    return;\r\n                }\r\n\r\n                if (typeof sound.loop === 'function') {\r\n                    sound.loop(loop || false);\r\n                } else {\r\n                    sound.loop = loop || false;\r\n                }\r\n\r\n                instance = sound.play({\r\n                    panning: [panning || 0, 0, 5],\r\n                    volume: volume || 1,\r\n                    loop: loop || false\r\n                });\r\n\r\n                return instance;\r\n            },\r\n            /**\r\n             * Stops playing the sound id\r\n             * \r\n             * @param {any} id\r\n             * @param {any} instanceId\r\n             * @returns\r\n             */\r\n            stop: function (id, instanceId) {\r\n                let sound = null;\r\n\r\n                if (!this.enabled) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    sound = this.audioCache[id];\r\n                } catch (err) {\r\n                    console.warn('[AM] WARN: unable to stop sound', id);\r\n                    return;\r\n                }\r\n\r\n                if (sound && typeof sound.stop === 'function') {\r\n                    sound.stop(instanceId || undefined);\r\n                }\r\n            }\r\n        };\n\n\n// WEBPACK FOOTER //\n// ./js/Audio/AudioManager.js","import Binary from 'Binary/Binary';\r\nimport AM from 'Audio/AudioManager';\r\nimport Pool from 'Core/Pool';\r\nimport Wad from 'web-audio-daw';\r\nimport Deferred from 'Core/Deferred';\r\nimport Dom from 'Core/Dom';\r\n\r\n    // build a new object instance without using new\r\n    function newObject(Obj) {\r\n        return new (Obj.bind.apply(Obj, arguments))();\r\n    }\r\n\r\n    /*jshint devel: true, bitwise: false*/\r\n    \"use strict\";\r\n    /**\r\n     * Handles resource loading at runtime\r\n     * \r\n     * Resources are loaded and retrieved using this manager.\r\n     * \r\n     * The ResourceManager can load at runtime the folowing types of resources:\r\n     *  - Images\r\n     *  - Sounds\r\n     *  - Maps (JSON-based)\r\n     * \r\n     */\r\n    export default {\r\n        isLocal: !!document.location.href.match(/^file:\\/\\//),\r\n        scriptMaxTime: 3000,\r\n        groupMaxTime: 5000,\r\n        /**\r\n         * This property holds all ressources that have been added to the ResourceManager,\r\n         * grouped by string identifier. By default, a new `any` group is added: any resource\r\n         * that is added with no group gets added this group.\r\n         */\r\n        resources: {\r\n            // by default all resources belong to any\r\n            'any': {\r\n                def: new Deferred(),\r\n                loadedRes: 0,\r\n                numRes: 0,\r\n                res: {},\r\n                progressCb: null,\r\n                errorCb: null\r\n            }\r\n        },\r\n        dynamicScripts: {},\r\n        iOS: !!navigator.userAgent.match(/iPhone|iPad/),\r\n        skipResources: ['script'],\r\n        async: true,\r\n        loading: false,\r\n        /**\r\n         * Retrieve a resource using its id with optionnal group\r\n         * \r\n         * @param {String} id The id of the resource to get\r\n         * @param {String=\"any\"} group the group to get the resource from\r\n         * @param {Boolean=false} fullObject returns the resource object if true. Otherwise return the resource only.\r\n         */\r\n        getResourceById: function(id, group, fullObject) {\r\n            // console.log('[RM] getting resource', id);\r\n            group = group || 'any';\r\n\r\n            let rsGroup = this.resources[group].res,\r\n                rs = rsGroup[id];\r\n\r\n            if (rs && rs.loaded) {\r\n                return fullObject === true ? rs : rs.elt;\r\n            } else {\r\n                if (this.dynamicScripts[id]) {\r\n                    return this.dynamicScripts[id];\r\n                } else {\r\n                    console.error('[RM] unknwon resource id', id);\r\n                    return ;\r\n                }\r\n\r\n                if (resource) {\r\n                    return resource.default;\r\n                } else {\r\n                    debugger;\r\n                    console.warn('[RM] WARN: could not find resource', id);                    \r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Allocates a new resource from the pool\r\n         * \r\n         * This method creates a new instance of the JavaScript object, retrieving it from\r\n         * the pool if the object supports it. If it does not it simply uses new to generate a new instance\r\n         * \r\n         * @param {String} id The id of the resource for which to create a new instance.\r\n         * \r\n         * @returns {Object} a new instance of the specified object.\r\n         */\r\n        newResourceFromPool: function(id) {\r\n            let resource = this.getResourceById(id);\r\n\r\n            if (typeof resource.createFromPool === 'function') {\r\n                console.log('getting resource from pool!');\r\n                return resource.createFromPool.apply(resource, Array.prototype.slice.call(arguments, 1));\r\n            } else {\r\n                console.log('no pool for this one: using new instead');\r\n                return newObject.apply(undefined, [resource].concat(Array.prototype.slice.call(arguments, 1)));\r\n            }\r\n        },\r\n        /**\r\n         * Creates a new group of resources.\r\n         * \r\n         * This allows to load a group of resources of any type\r\n         * with a single load call.\r\n         * \r\n         * This is usefull for loading every resource of a single\r\n         * game's level for example\r\n         * \r\n         * @private\r\n         */\r\n        _createGroup: function(groupName) {\r\n            if (!this._groupExists(groupName)) {\r\n                this.resources[groupName] = {\r\n                    def: new Deferred(),\r\n                    loadedRes: 0,\r\n                    numRes: 0,\r\n                    res: {},\r\n                    progressCb: null,\r\n                    errorCb: null\r\n                };\r\n            } else {\r\n                this.resources[groupName].def = new Deferred();\r\n            }\r\n//\t\t\t\t\tconsole.log('[RM] cannot add resource group', groupName, 'because it already exists');\r\n//\t\t\t\t}\r\n        },\r\n        /**\r\n         * Checks if a group already exists\r\n         * \r\n         * @param {String} groupName The name of the group to check.\r\n         * \r\n         * @returns {Boolean} true if the group already exists.\r\n         * \r\n         * @private\r\n         */\r\n        _groupExists: function(groupName) {\r\n            return typeof this.resources[groupName] !== 'undefined';\r\n        },\r\n        /**\r\n         * Add new resource(s) into the specified group\r\n         * \r\n         * @param {Object|Array} resource a single or a group of resources to load\r\n         * @param {String} group the name of the group to add the resources into\r\n         * \r\n         * @returns {Deferred} a new Deferred that will be resolved once the\r\n         * resources have been loaded.\r\n         * \r\n         * *Note* This method only adds the resources to the group\r\n         * but do not load them.\r\n         * \r\n         * @example\r\n         * \r\n         * ResourceManager.addResources({\r\n         *  id: 'sprites',\r\n         *  type: 'image',\r\n         *  src: './sprites/gem.png'\r\n         * }, \"sprites\");\r\n         * \r\n         * // resource type can be image|map|audio\r\n         */\r\n        addResources: function(resource, group) {\r\n            group = group || 'any';\r\n\r\n            this._createGroup(group);\r\n\r\n            let i,\r\n                resGroup = this.resources[group];\r\n\r\n            if (resource !== null) {\r\n                if (typeof resource === 'object' && resource.constructor === Array) {\r\n                    for (i in resource) {\r\n                        if (typeof resGroup.res[resource[i].id] === 'undefined' && this.skipResources.indexOf(resource[i].type) === -1) {\r\n                            // we could use jQuery.extend but this seems to be a little faster\r\n                            // and we can easily remove jQuery if needed then\r\n                            resGroup.res[resource[i].id] = JSON.parse(JSON.stringify(resource[i]));\r\n                            resGroup.numRes++;\r\n                        }\r\n                    }\r\n                } else if (typeof resGroup.res[resource.id] === 'undefined' && this.skipResources.indexOf(resource.type) === -1) {\r\n                    resGroup.res[resource.id] = JSON.parse(JSON.stringify(resource));\r\n                    resGroup.numRes++;\r\n                }\r\n            }\r\n\r\n            if (resource === null || resGroup.numRes === resGroup.loadedRes) {\r\n                resGroup.def.resolve(true);\r\n            }\r\n            // console.log('[RM] added resources', resGroup, 'group', group);\r\n\r\n            return resGroup.def.promise;\r\n        },\r\n        /**\r\n         * Attempts to load the next resource in the specified group\r\n         * \r\n         * @param {String} groupName the name of the group to use.\r\n         */\r\n        loadNextResource: function(groupName) {\r\n            let group = this.resources[groupName],\r\n                i;\r\n\r\n            for (i in group.res) {\r\n                if (!group.res[i].loaded && this.skipResources.indexOf(group.res[i].type) === -1) {\r\n                    this._loadResource(group.res[i], groupName);\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n        // load ressources, either unique resources with id, or group id\r\n        /**\r\n         * Loads all resources found in the specified group, optionnaly\r\n         * calling a callback after each file has been loaded.\r\n         * \r\n         * @param {String} group The name of the group to load\r\n         * @param {Function=undefined} progressCb an optionnal progress callback\r\n         * @param {Function=undefined} errorCb an optionnal error callback\r\n         * \r\n         */\r\n        loadResources: function(group, progressCb, errorCb) {\r\n            group = group || 'any';\r\n\r\n            if (this.loading === true) {\r\n                console.warn('[ResourceManager] loadResources() -> already loading');\r\n                return;\r\n            } else {\r\n                this.loading = true;\r\n            }\r\n\r\n            let resGroup = this.resources[group],\r\n                nextRes = null,\r\n                i,\r\n                size = 0;\r\n\r\n            resGroup.progressCb = progressCb || null;\r\n            resGroup.errorCb = errorCb || null;\r\n\r\n            // FIXME: simply count the num of resources and get a ref to the first one\r\n            // guess it could be cleaner\r\n            for (i in resGroup.res) {\r\n                if (!resGroup.res[i].loaded && this.skipResources.indexOf(resGroup.res[i].type) === -1) {\r\n                    size++;\r\n                    if (this.async) {\r\n                        this._loadResource(resGroup.res[i], group);\r\n                    } else if (nextRes === null) {\r\n                        nextRes = resGroup.res[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // load the first one\r\n            if (!this.async) {\r\n                this._loadResource(nextRes, group);\r\n            }\r\n\r\n            if (size === 0) {\r\n                console.warn('[ResourceManager] no ressource to load');\r\n                // force back loading to false: this happens when scene elements has already\r\n                // been loaded\r\n                this.loading = false;\r\n                return;\r\n            }\r\n\r\n            resGroup.gpTimeout = setTimeout(() => {\r\n                var notLoaded = [],\r\n                    resId;\r\n\r\n                if (resGroup.gpTimeout && resGroup.def.state() === 'rejected') {\r\n                    resGroup.gpTimeout = null;\r\n\r\n                    console.error('[RM] Unable to load the following resources after', this.groupMaxTime / 1000, 'sec');\r\n                    for (resId in resGroup.res) {\r\n                        if (!resGroup.res[resId].loaded) {\r\n                            notLoaded.push('[' + resGroup.res[resId].type + '] ' + resId);\r\n                            console.warn('[' + resGroup.res[resId].type + '] ' + resId + ': ' + resGroup.res[resId].src);\r\n                        }\r\n                    }\r\n\r\n                    // TODO: pass what was loaded, and what was not to the error callback...\r\n                    if (resGroup.errorCb) {\r\n                        resGroup.errorCb('Unable to get all resources after', this.groupMaxTime, notLoaded);\r\n                    }\r\n                }\r\n            }, this.groupMaxTime);\r\n        },\r\n        /**\r\n         * Converts an image into a canvas element\r\n         * \r\n         * @param {Image} image The image to convert\r\n         * \r\n         * @returns {Canvas} a new canvas element containing the image\r\n         * \r\n         * @private\r\n         */\r\n        getCanvasFromImage: function(image) {\r\n            let canvas = document.createElement('canvas');\r\n\r\n            canvas.width = image.naturalWidth;\r\n            canvas.height = image.naturalHeight;\r\n\r\n            canvas.getContext('2d').drawImage(image, 0, 0);\r\n\r\n            return canvas;\r\n        },\r\n        /**\r\n         * starts loading an image\r\n         * \r\n         * @param {Object} res an Object describing the resource to load\r\n         * @param {String} gpName the name of the group that the resource came from\r\n         * \r\n         * @returns {Deferred} a new promise that will be resolved when the file has been loaded.\r\n         * @private\r\n         */\r\n        loadImage: function(res, gpName) {\r\n            let img = new Image(),\r\n                that = this,\r\n                def = new Deferred(),\r\n                gp = that.resources[gpName];\r\n\r\n            // console.log('[RM] loading image', res.src);\r\n\r\n            img.onload = function() {\r\n                // on Chrome/Win calling drawImage to draw from canvas to canvas is abnormally slow (20-30ms to draw a 20x20px sprite on a core2quad + ati card)\r\n                // so it's disabled for now\r\n                // res.elt = that.getCanvasFromImage(this);                \r\n                res.elt = img;\r\n                res.img = this;\r\n                res.loaded = true;\r\n                that._resLoaded(gpName);\r\n                def.resolve(true);\r\n\r\n                // console.log('[RM] loaded image', res.src);\r\n            };\r\n\r\n            img.src = res.src;\r\n\r\n            return def.promise;\r\n        },\r\n        /**\r\n         * Creates a pool for a specified object\r\n         * \r\n         * This method pre-allocates objects for later use.\r\n         * \r\n         * @param {Function} Obj a new object to create\r\n         * @param {Number} size the size of the pool\r\n         * \r\n         */\r\n        createObjectPool: function(Obj, size) {\r\n            Pool.create(Obj, size);\r\n        },\r\n        /**\r\n         * Register a script as resource: this allows to retrieve it using the resourceManager\r\n         * at runtime.\r\n         * \r\n         * `notes`\r\n         * During athenajs development, systemjs loader was used instead of Webpack\r\n         * systemjs allows to load any script during *runtime*\r\n         * \r\n         * This allowed to load script (sprite) resources at runtime, on-demand.\r\n         * \r\n         * Unfortunately, this is not possible at all with ES6/Webpack which needs to\r\n         * know during build-process which scripts will be needed at runtime to build\r\n         * dependency graphs.\r\n         * \r\n         */\r\n        registerScript: function(id, elt, poolSize) {\r\n            let existing = this.dynamicScripts[id];\r\n\r\n            if (poolSize) {\r\n                this.createObjectPool(elt, poolSize);                \r\n            }\r\n\r\n            if (existing) {\r\n                console.error('existing script with the id', id, 'should I replace it?');\r\n            } else {\r\n                this.dynamicScripts[id] = elt;\r\n            }\r\n        },\r\n        /**\r\n         * loads a new external script: this is not supported anymore\r\n         * since webpack cannot load random script file\r\n         * \r\n         * @obsolete\r\n         * @private\r\n         */\r\n        loadScript: function(res, gpName, callback) {\r\n            let loaded = new Deferred(),\r\n                gp = this.resources[gpName];\r\n                /*\r\n                script = null,\r\n                timeout = 0;\r\n                */\r\n\r\n            console.error('loadScript not supported');\r\n            // require.ensure([], function() {\r\n            //     debugger;\r\n            //     var res = require(res.src);\r\n            // })\r\n            console.log('[RM] loading script', res.src);\r\n\r\n            // remove ending .js since it shouldn't be there for require js\r\n/*\r\n            res.src = res.src.replace(/\\.js$/, '');\r\n\r\n            System.import(res.src).then((scriptEval) => {\r\n                console.log('[RM] loaded AJAX script', res.src, scriptEval);\r\n                res.elt = scriptEval.default ? scriptEval.default : scriptEval;\r\n                res.loaded = true;\r\n\r\n                if (res.poolSize) {\r\n                    this.createObjectPool(res.elt, res.poolSize);\r\n                }\r\n\r\n                if (!callback) {\r\n                    this._resLoaded(gpName);\r\n                    loaded.resolve(true);\r\n                } else {\r\n                    var newDef = callback.call(this, res, gpName);\r\n                    newDef.done(function() {\r\n                        loaded.resolve(true);\r\n                    });\r\n                }\r\n\r\n            }).catch(function(err) {\r\n                console.log('resource not loaded', err);\r\n                gp.def.reject('Unable to load resource \"' + res.src + '\" [' + res.id + ']');\r\n            });\r\n*/\r\n            return loaded.promise;\r\n        },\r\n\r\n        /**\r\n         * Loads a new Audio file using standard HTML5 Audio\r\n         * \r\n         * @param {Object} res a descriptor for the sound to load\r\n         * @param {String} gpName the name of the group to load the audio file from\r\n         * \r\n         * @returns {Deferred} a new promise that will be resolved once the file has been loaded\r\n         */\r\n        loadAudio: function(res, gpName) {\r\n            console.log('[RM] loading sound', res.src);\r\n\r\n            let that = this,\r\n                audio = new Audio(),\r\n                def = new Deferred(),\r\n                gp = that.resources[gpName];\r\n                \r\n            function onLoad() {\r\n                // canplaythrough event is sent not only on first load, but after the song has been played (and has been rewinded)\r\n                // so we remove it to prevent from triggering again\r\n                this.removeEventListener('canplaythrough', onLoad);\r\n                console.log('[RM] audioLoaded', res.src);\r\n                res.elt = this;\r\n                res.loaded = true;\r\n                AM.addSound(res.id, this);\r\n                that._resLoaded(gpName);\r\n                def.resolve(true);\r\n            }\r\n\r\n            audio.preload = 'auto';\r\n            audio.addEventListener('canplaythrough', onLoad);\r\n\r\n            audio.addEventListener('loadstart', function() {\r\n                console.log('loadStarted', audio.src);\r\n            });\r\n\r\n            audio.src = res.src;\r\n\r\n            return def.promise;\r\n        },\r\n\r\n        /**\r\n         * Loads a new Audio file using the WAD library\r\n         * \r\n         * @param {Object} res a descriptor for the sound to load\r\n         * @param {String} gpName the name of the group to load the audio file from\r\n         * \r\n         * @returns {Deferred} a new promise that will be resolved once the file has been loaded\r\n         */\r\n        loadWadAudio: function(res, gpName) {           \r\n            let that = this,\r\n                gp = that.resources[gpName],\r\n                def = new Deferred(),\r\n                sound = new Wad({\r\n                    source: res.src,\r\n                    callback: function() {\r\n                        res.elt = sound;\r\n                        res.loaded = true;\r\n                        AM.addSound(res.id, sound);\r\n                        that._resLoaded(gpName);\r\n                        def.resolve(true);\r\n                    }\r\n                });\r\n\r\n            return def.promise;\r\n        },\r\n\r\n        /**\r\n         * Loads a new Audio file using the Howler library\r\n         * \r\n         * @param {Object} res a descriptor for the sound to load\r\n         * @param {String} gpName the name of the group to load the audio file from\r\n         * \r\n         * @returns {Deferred} a new promise that will be resolved once the file has been loaded\r\n         */\r\n        loadHowlerAudio: function(res, gpName) {\r\n            let that = this,\r\n                gp = that.resources[gpName],\r\n                def = new Deferred(),\r\n                sound = new Howl.Howl({\r\n                    urls: [res.src],\r\n                    onload: function() {\r\n                        res.elt = sound;\r\n                        res.loaded = true;\r\n                        AM.addSound(res.id, sound);\r\n                        that._resLoaded(gpName);\r\n                        def.resolve(true);\r\n                    }\r\n                });\r\n\r\n            return def.promise;\r\n        },\r\n\r\n        /**\r\n         * Loads a JSON file\r\n         * \r\n         * @param {Object} res The JSON file descriptor\r\n         * @param {String} gpName The name of the group to load the file from\r\n         * @param {Function} callback An optionnal callback to execute once the file has been loaded\r\n         * \r\n         * @returns {Deferred} a promise that will be resolved once the file has been loaded.\r\n         */\r\n        loadJSON: function(res, gpName, callback) {\r\n            let def = new Deferred();\r\n\r\n            fetch(res.src).then(response => {\r\n                if (response.status === 200) {\r\n                    return response.json();\r\n                } else {\r\n                    throw 'Error getting photo list';\r\n                }\r\n            })\r\n            .then(json => {\r\n                res.elt = json;\r\n                res.loaded = true;\r\n                if (!callback) {\r\n                    this._resLoaded(gpName);\r\n                    loaded.resolve(true);\r\n                } else {\r\n                    var newDef = callback.call(this, res, gpName);\r\n                    newDef.then(() => {\r\n                        def.resolve(true);\r\n                    });\r\n                }\r\n            });\r\n        },\r\n        /**\r\n         * Loads binary data into an ArrayBuffer\r\n         *\r\n         * @param {Object} res The JSON file descriptor\r\n         * @param {String} gpName The name of the group to load the file from\r\n         * \r\n         * @returns {Deferred} a promise that will be resolved once the file has been loaded.\r\n         * \r\n         * @private\r\n         */\r\n        loadMapData: function(res, gpName) {\r\n            let def = new Deferred(),\r\n                gp = this.resources[gpName];\r\n\r\n            Binary.getArrayBuffer((document.location.href.match('warpdesign.fr') ? '/gods/' : '') + res.elt.dataUrl).then((arrayBuffer) => {\r\n                res.elt.buffer = arrayBuffer;\r\n                res.loaded = true;\r\n                this._resLoaded(gpName);\r\n                def.resolve(true);\r\n\r\n            }, () => {\r\n                gp.def.reject('Unable to load map resource \"' + res.src + '\" [' + res.id + ']');\r\n            });\r\n\r\n            return def.promise;\r\n        },\r\n        /**\r\n         * Internal method that gets called once a resource has been loaded\r\n         * \r\n         * If there is resource remaining to be loaded, this method will load the next resource.\r\n         * Otherwise it will resolve the group's loading promise.\r\n         * \r\n         * @private\r\n         */\r\n        _resLoaded: function(groupName) {\r\n            let group = this.resources[groupName];\r\n\r\n            group.loadedRes++;\r\n\r\n            /*\r\n                Debug stuff\r\n            */\r\n            new Dom('span.loaded').html(group.loadedRes);\r\n\r\n            if (group.progressCb) {\r\n                group.progressCb.call(this, Math.floor((group.loadedRes * 100) / group.numRes));\r\n            }\r\n\r\n            if (group.loadedRes === group.numRes) {\r\n                // console.log('[RM] need to resolve stuff :)) ' + group.loadedRes + '/' + group.numRes);\r\n                this.loading = false;\r\n                if (group.gpTimeout !== null) {\r\n                    clearTimeout(group.gpTimeout);\r\n                }\r\n                group.def.resolve(true);\r\n            } else if (!this.async){\r\n               //  console.log('[RM] more stuff to load !', group.loadedRes + '/' + group.numRes);\r\n                this.loadNextResource(groupName);\r\n            } else {\r\n                // console.log('[RM] more stuff to load !', group.loadedRes + '/' + group.numRes);\r\n            }\r\n        },\r\n        /**\r\n         * Loads the specificied resource from specified group\r\n         * \r\n         * @param {Object} res The JSON file descriptor\r\n         * @param {String} gpName The name of the group to load the file from\r\n         * \r\n         * @private\r\n         */\r\n        _loadResource: function(res, groupName) {\r\n            // console.log('[RM] loading', res);\r\n            switch(res.type) {\r\n                case 'image':\r\n                    return this.loadImage(res, groupName);\r\n\r\n                case 'audio':\r\n                    // return this.loadHowlerAudio(res, groupName);\r\n                    // return this.loadAudio(res, groupName);\r\n                    // return this.loadAudio(res, groupName);\r\n                    return this.loadWadAudio(res, groupName);\r\n                    /*\r\n                    if (this.useWad) {\r\n                        return this.loadWadAudio(res, groupName);\r\n                    } else {\r\n                        return this.loadHowlerAudio(res, groupName);\r\n                    }*/\r\n\r\n\r\n                case 'script':\r\n                    return this.loadScript(res, groupName);\r\n\r\n                // case 'map'\r\n                default:\r\n                    // return this.loadScript(res, groupName, this.loadMapData);\r\n                    return this.loadJSON(res, groupName, this.loadMapData);\r\n            }\r\n        }\r\n    };\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Resource/ResourceManager.js","/* Very small and simple jQuery-like object */\r\n\r\n/**\r\n * Dom is a very simple jQuery-like object that allows to manipulate\r\n * a collection of DOM elements.\r\n * \r\n * As in jQuery, you may manipulate Dom collections using []\r\n * \r\n * @class\r\n * @constructor \r\n */\r\nfunction Dom(selector) {\r\n    if (selector.match(/^#|\\./)) {\r\n        this.push(...document.querySelectorAll(selector));\r\n    } else {\r\n        this.push(document.createElement(selector));\r\n    }\r\n}\r\n\r\nDom.prototype = new Array();\r\n\r\nObject.assign(Dom.prototype, {\r\n    /**\r\n     * jQuery-like CSS method to easily set multiple styles on a dom collection\r\n     * \r\n     * @param {String|Object} prop or list of properties with their new value\r\n     * @param {String} val value of the property\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */\r\n    css: function(prop, val) {\r\n        if (typeof prop === 'object') {\r\n            this.forEach((node) => {\r\n                const style = node.style;\r\n\r\n                for (const name in prop) {\r\n                    style[name] = prop[name];\r\n                }\r\n            });\r\n        } else {\r\n            this.forEach((node) => {\r\n                node.style[prop] = val;\r\n            })\r\n        }\r\n        return this;        \r\n    },\r\n\r\n    /**\r\n     * Append current collection to the element with a specific selector \r\n     * \r\n     * @param {String|HTMLElement} selector Target element where to append selected elements.\r\n     * It can either be a CSS selector or a DOM HTMLElement.\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */\r\n    appendTo: function(selector) {\r\n        const target = typeof selector === 'object' && selector || document.querySelector(selector);\r\n\r\n        if (target) {\r\n            this.forEach((node) => {\r\n                target.appendChild(node);\r\n            });\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Change multiple attributes at once\r\n     * \r\n     * @param {String|Object} att attribute name to modify or list of attributes+values to change\r\n     * @param {String} val value of the attribute to set\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */    \r\n    attr: function(att, val) {\r\n        if (typeof att === 'object') {\r\n            this.forEach((node) => {\r\n                for (const name in att) {\r\n                    node.setAttribute(name, att[name]);\r\n                }\r\n            });\r\n        } else {\r\n            this.forEach((node) => {\r\n                node.setAttribute(att, val);\r\n            });\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a new Class to a DOM collection\r\n     * \r\n     * @param {String} name new class to add\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */    \r\n    addClass: function(name) {\r\n        this.forEach((node) => {\r\n            node.classList.add(name);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes innerHTML of a collection\r\n     * \r\n     * @param {String} html to set as innerHTML\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */    \r\n    html: function(html) {\r\n        this.forEach((node) => node.innerHTML = html);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shows specified set of elements\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */\r\n    show: function() {\r\n        this.forEach(node => {\r\n            node.style.display = 'block';\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Hides specified set of elements\r\n     * @returns {Dom} `this`\r\n     * \r\n     * @memberof Dom#\r\n     */\r\n    hide: function() {\r\n        this.forEach(node => {\r\n            node.style.display = 'node';\r\n        });\r\n    }    \r\n});\r\n\r\nexport default Dom;\n\n\n// WEBPACK FOOTER //\n// ./js/Core/Dom.js","import Deferred from 'Core/Deferred';\n\n    /*jshint devel: true, bitwise: false*/\n    class Effect{\n        constructor(options, display) {\n            this.easing = null;\n            this.context = options.context || this;\n            \n            // TODO: we may need width/height for sprites as well\n            // => pass the currentWidth/Height to fake display size\n            if (typeof display !== 'undefined') {\n                this.width = display.width;\n                this.height = display.height;\n            }\n\n            this.startValue = typeof options.startValue !== 'undefined' ? options.startValue : 0;\n            this.endValue = typeof options.endValue !== 'undefined' ? options.endValue : 1;\n            this.loop = !!options.loop || false;\n\n            this.duration = options.duration || 400;\n        }\n        \n        setEasing(easing) {\n            this.easing = easing;\n        }\n        \n        start() {\n            this.def = new Deferred();\n\n            this.startTime = new Date().getTime();\n\n            this.ended = false;\n\t\t\tthis.stopped = false;\n\n            return this.def.promise;\n        }\n        \n        stop(setEndValue) {\n          this.stopped = true;\n        }\n        \n        process(ctx, fxCtx, obj) {\n            let currentTime = new Date().getTime(),\n                ellapsedTime = currentTime - this.startTime,\n                t = ellapsedTime / this.duration;\n\n            if (this.stopped || ellapsedTime >= this.duration) {\n                if (this.stopped || this.loop === false) {\n                    // set progress to 1 to avoid weird side effects (eg. opacity set to a negative number since anim progress may be > 1)\n                    this.animProgress = 1;\n\n                    this.ended = true;\n                    // since this is called inside the render loop, we must be sure call has ended before resolving\n                    // FIXES: #BUG: playing the same scene calls twice the renderLoop\n                    setTimeout(() => { this.def.resolve(true); }, 0);\n                } else {\n                    // console.log('looping effect');\n                    this.start();\n                }\n            } else {\n                this.animProgress = this.easing(t, ellapsedTime, 0, 1, this.duration);\n            }\n\n            return this.ended;\n        }\n    };\n\n    export default Effect;\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Effect/Effect.js","// import VirtualJoystick from 'Joystick';\r\n\r\n    /*jshint devel: true*/\r\n    /**\r\n     * Handles keyboard input (joystick input doesn't work correctly yet).\r\n     * \r\n     * Key presses are stored in a simple hash this.keyPressed with keyCode as key, and attached handlers are stored in\r\n     * another hash this.keyCb.\r\n     * \r\n     * The InputManager can also be used to record keystrokes which can then be played back to produce game demos for example.\r\n     * \r\n     * @example\r\n     * \r\n     * // example state of InputManager.keyPressed where `up` key is down and `down` key has just been released:\r\n     * { 32: true, 40: false}\r\n     * \r\n     */\r\n    export default {\r\n        /**\r\n         * A list of common keyCodes\r\n         */\r\n        keys: {\r\n            'UP': 38,\r\n            'DOWN': 40,\r\n            'LEFT': 37,\r\n            'RIGHT': 39,\r\n            'SPACE': 32,\r\n            'ENTER': 13,\r\n            'ESCAPE': 27,\r\n            'CTRL': 17\r\n        },\r\n        /**\r\n         * List of common pad buttons\r\n         */\r\n        PAD_BUTTONS: {\r\n            32: 1, // Face (main) buttons\r\n            FACE_0: 1,\r\n            FACE_3: 2,\r\n            FACE_4: 3,\r\n            LEFT_SHOULDER: 4, // Top shoulder buttons\r\n            RIGHT_SHOULDER: 5,\r\n            LEFT_SHOULDER_BOTTOM: 6, // Bottom shoulder buttons\r\n            RIGHT_SHOULDER_BOTTOM: 7,\r\n            SELECT: 8,\r\n            START: 9,\r\n            LEFT_ANALOGUE_STICK: 10, // Analogue sticks (if depressible)\r\n            RIGHT_ANALOGUE_STICK: 11,\r\n            38: 12, // Directional (discrete) pad\r\n            40: 13,\r\n            37: 14,\r\n            39: 15\r\n        },\r\n        axes: {\r\n\r\n        },\r\n        // gamepadSupport: (!!navigator.webkitGetGamepads !!navigator.webkitGetGamepads || !!navigator.webkitGamepads) && navigator.webkitGetGamepads().length && navigator.webkitGetGamepads()[0],\r\n        gamepadSupport: false,\r\n        recording: false,\r\n        playingEvents: false,\r\n        playingPos: 0,\r\n        recordedEvents: [],\r\n        pad: null,\r\n        keyPressed: {},\r\n\t\tpadPressed: {},\r\n        keyCb: {},\r\n        gameRef: null,\r\n        inputMode: 'keyboard',\r\n        // virtual joystick instance\r\n        dPadJoystick: null,\r\n        jPollInterval: 0,\r\n        /**\r\n         * Initializes the InputManager with a reference to the game.\r\n         * \r\n         * This method prepares the InputManager by reseting keyboard states/handlers and\r\n         * set current inputMode\r\n         * \r\n         * @param {Game} gameRef A reference to the game being used.\r\n         * \r\n         * @private\r\n         */\r\n        _init: function(gameRef) {\r\n            this.gameRef = gameRef;\r\n\r\n            this._installInputModeSwitchHandler();\r\n\r\n            this._installKBEventHandlers();\r\n\r\n            // this._initVirtualJoystick();\r\n\r\n            this.setInputMode(this.inputMode);\r\n        },\r\n        /**\r\n         * Private handler that is supposed to detect touchEvent and automatically switch between keyboard & touch\r\n         * inputs. Unfortunately it tourned out to not be so easy.\r\n         * \r\n         * @private\r\n         */\r\n        _installInputModeSwitchHandler : function() {\r\n            // we cannot have several input devices (ie: keyboard, joystick,...) running at the same time\r\n            // since they will interfer with each other (pressing a key will stop touch from working correctly)\r\n            // we don't want the user to have to choose input mode using a menu or shortcut\r\n            // instead, we want to have an automatic detection/switch of input mode which works like this:\r\n            // by default, input mode if set to keyboard\r\n            // if a touch is detected, input is set to joystick and kb detection is disabled\r\n            // if a keydown is detected, joystick mode is disabled and kb detection is enabled\r\n            document.addEventListener('touchstart', () => {\r\n                this.setInputMode('joystick');\r\n            });\r\n\r\n            document.addEventListener('keydown', () => {\r\n                this.setInputMode('keyboard');\r\n            });\r\n        },\r\n        /**\r\n         * Starts recording input events. They are stored into `InputManager.recordedEvents`\r\n         */\r\n        startRecordingEvents: function() {\r\n            if (!this.recording) {\r\n                this.recordedEvents.length = 0;\r\n                this.recording = true;\r\n                console.log('[InputManager] Starting record of input events!');\r\n            }\r\n        },\r\n        /**\r\n         * Stops recording events.\r\n         */\r\n        stopRecordingEvents: function() {\r\n            this.recording = false;\r\n            console.log('[InputManager] Stoping record of input events, recorded', this.recordedEvents.length, 'events');\r\n        },\r\n        /**\r\n         * After events have been reccorded they can be played back using this method.\r\n         */\r\n        playRecordedEvents: function() {\r\n            if (!this.playingEvents) {\r\n                console.log('[InputManager] Starting to play an existing record of input events!');\r\n                this.playingEvents = true;\r\n                this.playPos = 0;\r\n            }\r\n        },\r\n        /**\r\n         * Sets next key states using recorded events\r\n         * \r\n         * TODO: add an optional callback to be called at the end of the playback\r\n         * so that demo can be looped.\r\n         */\r\n        nextRecordedEvents: function() {\r\n            if (this.playingPos >= this.recordedEvents.length) {\r\n                this.playingEvents = false;\r\n                // TODO: reset keys so that movement does not continue\r\n                this.keyPressed = {\r\n                    38: false,\r\n                    40: false,\r\n                    37: false,\r\n                    39: false,\r\n                    32: false,\r\n                    13: false,\r\n                    27: false,\r\n                    17: false\r\n                };\r\n                console.log('[InputManager] Reached the end of recorded events, resetting keys status to default!');\r\n            } else {\r\n                this.keyPressed = this.recordedEvents[this.playingPos++];\r\n                // TODO: we should call any callback as well\r\n                // for (keyCode in this.keyPressed) {\r\n                //  if (this.keyPressed[keyCode] === true && this.keyCb[keyCode]) {\r\n                //      this.keyCb[keyCode].down.fire();\r\n                //  }\r\n                // }\r\n                //\r\n            }\r\n        },\r\n        /**\r\n         * Saves current event state onto the recordedEvents stack\r\n         * \r\n         * @private\r\n         */\r\n        recordEvents: function() {\r\n/*            'UP': 38,\r\n            'DOWN': 40,\r\n            'LEFT': 37,\r\n            'RIGHT': 39,\r\n            'SPACE': 32,\r\n            'ENTER': 13,\r\n            'ESCAPE': 27,\r\n            'CTRL': 17*/\r\n            this.recordedEvents.push(JSON.parse(JSON.stringify(this.keyPressed)));\r\n        },\r\n        /**\r\n         * Changes input mode\r\n         * \r\n         * @param {String} mode Changes current input mode, can be `virtual_joystick`, `keyboard`, `gamepad`\r\n         */\r\n        setInputMode: function(mode) {\r\n            if (this.inputMode === mode) {\r\n                return;\r\n            }\r\n\r\n            switch(mode) {\r\n                case 'virtual_joystick':\r\n                    if (this.dPadJoystick) {\r\n                        this.jPollInterval = setInterval(this._pollJoystick.bind(this), 1/30 * 1000);\r\n                    }\r\n                    break;\r\n\r\n                case 'keyboard':\r\n                    this._clearJoystickPoll();\r\n                    break;\r\n\r\n                case 'gamepad':\r\n                    this._clearJoystickPoll();\r\n                    this.jPollInterval = setInterval(this._pollGamepad.bind(this), 1/30 * 1000);\r\n                    break;\r\n            }\r\n\r\n            this._resetKeys();\r\n            this.inputMode = mode;\r\n        },\r\n        /**\r\n         * Resets keys that have been pressed.\r\n         * \r\n         * @private\r\n         */\r\n        _resetKeys: function() {\r\n            for (let key in this.keyPressed) {\r\n                this.keyPressed[key] = false;\r\n            }\r\n        },\r\n        /**\r\n         * Checks for a new joystick to be connected onto the machine and changes the inputMode to `gamepad`\r\n         * when a new joypad is detected.\r\n         */\r\n\t\t_pollNewGamepad: function() {\r\n\t\t\tlet gamepads = (navigator.getGamepads && navigator.getGamepads()) || (navigator.webkitGetGamepads && navigator.webkitGetGamepads()) || navigator.webkitGamepads;\r\n\t\t\tif (!this.pad && gamepads && gamepads.item() !== null) {\r\n\t\t\t\tthis.pad = gamepads.item();\r\n\r\n\t\t\t\tif (!this.gamepadSupport) {\r\n\t\t\t\t\tconsole.log('[Event] Oh oh! Looks like we have a new challenger: ', this.pad.id);\r\n\t\t\t\t\tthis.gamepadSupport = true;\r\n                    this.setInputMode('gamepad');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n        /**\r\n         * \r\n         */\r\n        _pollGamepad: function(key) {\r\n            // normal buttons\r\n            // if (key === this.keys.space) {\r\n            //     if (this.pad.buttons[this.PAD_BUTTONS[key]].pressed === true) {\r\n            //         this.padPressed[key] = true;\r\n            //     } else {\r\n            //         this.padPressed[key] = false;\r\n            //     }\r\n            // }\r\n\r\n            // special case for dpad on Linux, cannot test on Windows since my pad does not support XInput...\r\n            // d-pad\r\n            if (this.pad.buttons[12].pressed) {\r\n                this.keyPressed[this.keys['UP']] = true;\r\n                this.keyPressed[this.keys['DOWN']] = false;\r\n            } else if (this.pad.buttons[13].pressed) {\r\n                this.keyPressed[this.keys['DOWN']] = true;\r\n                this.keyPressed[this.keys['UP']] = false;\r\n            } else {\r\n                this.keyPressed[this.keys['DOWN']] = false;\r\n                this.keyPressed[this.keys['UP']] = false;\r\n            }\r\n\r\n            if (this.pad.buttons[15].pressed) {\r\n                this.keyPressed[this.keys['RIGHT']] = true;\r\n                this.keyPressed[this.keys['LEFT']] = false;\r\n            } else if (this.pad.buttons[14].pressed) {\r\n                this.keyPressed[this.keys['LEFT']] = true;\r\n                this.keyPressed[this.keys['RIGHT']] = false;\r\n            } else {\r\n                this.keyPressed[this.keys['LEFT']] = false;\r\n                this.keyPressed[this.keys['RIGHT']] = false;\r\n            }\r\n            // stick 1\r\n            /*\r\n            if (this.pad.axes[1] === -1) {\r\n                this.keyPressed[this.keys['UP']] = true;\r\n                this.keyPressed[this.keys['DOWN']] = false;\r\n            } else if (this.pad.axes[1] === 1) {\r\n                this.keyPressed[this.keys['DOWN']] = true;\r\n                this.keyPressed[this.keys['UP']] = false;\r\n            } else {\r\n                this.keyPressed[this.keys['DOWN']] = false;\r\n                this.keyPressed[this.keys['UP']] = false;\r\n            }\r\n\r\n            if (this.pad.axes[0] === 1) {\r\n                this.keyPressed[this.keys['RIGHT']] = true;\r\n                this.keyPressed[this.keys['LEFT']] = false;\r\n            } else if (this.pad.axes[0] === -1) {\r\n                this.keyPressed[this.keys['LEFT']] = true;\r\n                this.keyPressed[this.keys['RIGHT']] = false;\r\n            } else {\r\n                this.keyPressed[this.keys['LEFT']] = false;\r\n                this.keyPressed[this.keys['RIGHT']] = false;\r\n            }\r\n            */\r\n        },\r\n        _getModifiers: function(event) {\r\n            return {\r\n                'ALT': true,\r\n                'SHIFT': true,\r\n                'CTRL': true,\r\n                'META': true\r\n            };\r\n        },\r\n        _initVirtualJoystick: function() {\r\n            let dPadJoystick,\r\n                fireJoystick;\r\n\r\n            console.log('[InputManager] _initVirtualJoystick');\r\n\r\n            // left joystick = view\r\n            dPadJoystick = this.dPadJoystick = new VirtualJoystick({\r\n                container: document.body,\r\n                strokeStyle: 'cyan',\r\n                limitStickTravel: true,\r\n                mouseSupport: true,\r\n                stickRadius: 60\r\n            });\r\n\r\n            dPadJoystick.addEventListener('touchStartValidation', function(event){\r\n                let touch = event.changedTouches[0];\r\n                if (touch.pageX >= window.innerWidth / 2) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // right joystick = fire button\r\n            fireJoystick = this.fireJoystick = new VirtualJoystick({\r\n                container\t: document.body,\r\n                strokeStyle: 'orange',\r\n                limitStickTravel: true,\r\n                mouseSupport\t: true,\r\n                stickRadius: 0\r\n            });\r\n\r\n            fireJoystick.addEventListener('touchStartValidation', function(event){\r\n                let touch = event.changedTouches[0];\r\n                if (touch.pageX < window.innerWidth / 2) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            /* fire button */\r\n            fireJoystick.addEventListener('touchStart', () => {\r\n                if (this.inputMode === 'virtual_joystick') {\r\n                    this.keyPressed[this.keys['CTRL']] = true;\r\n                }\r\n            });\r\n\r\n            fireJoystick.addEventListener('touchEnd', () => {\r\n                if (this.inputMode === 'virtual_joystick') {\r\n                    this.keyPressed[this.keys['CTRL']] = false;\r\n                }\r\n            });\r\n        },\r\n        _clearJoystickPoll: function() {\r\n            if (this.jPollInterval) {\r\n                clearInterval(this.jPollInterval);\r\n                this.jPollInterval = 0;\r\n            }\r\n        },\r\n        _pollJoystick: function(){\r\n            let down = [],\r\n                up = [],\r\n                joystick = this.dPadJoystick,\r\n                fire = this.fireJoystick;\r\n\r\n            /* directions */\r\n            if (Math.abs(joystick.deltaX()) >= 10) {\r\n                if (joystick.left()) {\r\n                    down.push('LEFT');\r\n                    up.push('RIGHT');\r\n                } else {\r\n                    down.push('RIGHT');\r\n                    up.push('LEFT');\r\n                }\r\n            } else {\r\n                up.push('LEFT');\r\n                up.push('RIGHT');\r\n            }\r\n\r\n            if (Math.abs(joystick.deltaY()) >= 10) {\r\n                if (joystick.up()) {\r\n                    down.push('UP');\r\n                    up.push('DOWN');\r\n                } else {\r\n                    down.push('DOWN');\r\n                    up.push('UP');\r\n                }\r\n            } else {\r\n                up.push('UP');\r\n                up.push('DOWN');\r\n            }\r\n\r\n            if (down.length) {\r\n                down.forEach((key) => {\r\n                    this.keyPressed[this.keys[key]] = true;\r\n                });\r\n            }\r\n\r\n            if (up.length) {\r\n                up.forEach((key) => {\r\n                    this.keyPressed[this.keys[key]] = false;\r\n                });\r\n            }\r\n\r\n            // TODO: what happens for up event ? should be set to up only when going from down to up and called here\r\n        },\r\n        _installKBEventHandlers: function() {\r\n            let gameRef = this.gameRef;\r\n\r\n            // TODO: move me somewhere else!\r\n            document.addEventListener('keydown', (event) => {\r\n\r\n                if (this.inputMode !== 'keyboard' || this.playingEvents) {\r\n                    return;\r\n                }\r\n\r\n                switch(event.keyCode) {\r\n                    case 32:\r\n                    case 37:\r\n                    case 38:\r\n                    case 39:\r\n                    case 40:\r\n                        event.preventDefault();\r\n                        break;\r\n                }\r\n\r\n                if (event.keyCode) {\r\n                    this.keyPressed[event.keyCode] = true;\r\n                }\r\n\r\n                // console.log('keydown', event.keyCode, '<-', this.keyPressed[37], '->', this.keyPressed[39]);\r\n\r\n                this.metas = this._getModifiers();\r\n\r\n                if (this.keyCb[event.keyCode] && gameRef && gameRef.running) {\r\n                    this.keyCb[event.keyCode].down.forEach((callback) => {callback();});\r\n                }\r\n            });\r\n\r\n            document.addEventListener('keyup', (event) => {\r\n                if (this.inputMode !== 'keyboard' || this.playingEvents) {\r\n                    return;\r\n                }\r\n\r\n                if (event.keyCode) {\r\n                    this.keyPressed[event.keyCode] = false;\r\n                }\r\n\r\n                // console.log('keyup', event.keyCode, '<-', this.keyPressed[37], '->', this.keyPressed[39]);\r\n\r\n                this.metas = this._getModifiers();\r\n\r\n                if (this.keyCb[event.keyCode] && gameRef && gameRef.running) {\r\n                    this.keyCb[event.keyCode].up.forEach((callback) => { callback(); });\r\n                }\r\n            });\r\n        },\r\n        getAllKeysStatus: function() {\r\n            const keys = Object.keys(this.keys),\r\n                result = {};\r\n\r\n            for (let i = 0; i < keys.length; ++i) {\r\n                result[array[i]] = this.getKeyStatus(array[i]);\r\n            }\r\n\r\n            return result;\r\n        },\r\n        getKeyStatus: function(key, reset) {\r\n\t\t\tlet keyPressed;\r\n\r\n            try {\r\n\t\t\t\t// GamePad insertion polling disabled\r\n\t\t\t\t// seems like Chrome & FF have different methods\r\n\t\t\t\t// current one only works with Chrome and I don't\r\n\t\t\t\t// want to waste time adding configuration for both\r\n\t\t\t\t// until spec if fully defined and not experimental\r\n\t\t\t\t// this._pollNewGamepad();\r\n\r\n                /*\r\n                if (this.pad) {\r\n                    this._pollGamepad(key);\r\n                }\r\n                */\r\n\r\n                keyPressed = this.keyPressed[key] || this.padPressed[key];\r\n\r\n\t\t\t\tif (keyPressed && reset === true) {\r\n\t\t\t\t\tthis.keyPressed[key] = '';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn keyPressed;\r\n\r\n            } catch(err) {\r\n\t\t\t\tdebugger;\r\n                return false;\r\n            }\r\n        },\r\n\r\n        installKeyCallback: function(key, event, callback) {\r\n            let keyCode = this.keys[key];\r\n\r\n            if (!this.keyCb[keyCode]) {\r\n                this.keyCb[keyCode] = {\r\n                    up: [],\r\n                    down: []\r\n                };\r\n            }\r\n\r\n            this.keyCb[keyCode][event].push(callback);\r\n        },\r\n\r\n        removeKeyCallback: function(key, event, callback) {\r\n            const index = this.keyCb[key][event].indexOf(callback);\r\n            if (index > -1) {\r\n                this.keyCb[key][event].splice(index, 1);\r\n            }\r\n            \r\n        },\r\n        clearEvents: function() {\r\n            this.keyPressed = {};\r\n            this.keyCb = {};\r\n        }\r\n    };\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Input/InputManager.js","\n    /*jshint devel: true, bitwise: false*/\n    var eventCallbacks = {};\n\n    export default {\n        notify: function(eventType, data) {\n            // console.log('[NM] got event', eventType, 'with data', data);\n            const params = {type: eventType, data: data};\n\n            if (eventCallbacks[eventType]) {\n                eventCallbacks[eventType].forEach((callback) => callback(params));\n            } else if (eventCallbacks['*']) {\n                eventCallbacks['*'].forEach((callback) => callback(params));\n            }\n        },\n        listen: function(eventType, method) {\n            console.log('[NM] listening to event', eventType);\n            let eventList = eventType.replace(/\\s+/g, ' ').split(' ');\n\n            eventList.forEach((eventType) => {\n                if (!eventCallbacks[eventType]) {\n                    eventCallbacks[eventType] = [];\n                }\n\n                eventCallbacks[eventType].push(method);\n            });\n        }\n    };\n\n\n\n// WEBPACK FOOTER //\n// ./js/Notification/NotificationManager.js","/* @flow */\r\nimport Promise from 'es6-promise';\r\n\r\n/*jshint devel: true, bitwise: false*/\r\n/**\r\n * Object that allows sending & receving binary data\r\n */\r\nexport default {\r\n    /**\r\n     * Sends binary as POST\r\n     * \r\n     * @param {ArrayBufferView} view\r\n     * @param {String} url to post binary data to\r\n     */    \r\n    sendArrayBufferView: function(view, url) {\r\n        const req = new XMLHttpRequest();\r\n\r\n        req.open('POST', url, true);\r\n\r\n        req.send(view);\r\n    },\r\n\r\n    /**\r\n     * Retrieves binary data from the server\r\n     * \r\n     * @param {String} url to get binary data from\r\n     * @returns promise that is fullfilled with ArrayBuffer or false if get failed\r\n     */        \r\n    getArrayBuffer: function(url) {\r\n        return new Promise((resolve, reject) => {\r\n            const req = new XMLHttpRequest();\r\n\r\n            req.open('GET', url, true);\r\n            req.responseType = 'arraybuffer';\r\n\r\n            req.onload = (event) => {\r\n                const arrayBuffer = req.response;\r\n\r\n                if (arrayBuffer) {\r\n                    resolve(arrayBuffer);\r\n                } else {\r\n                    reject(false);\r\n                }\r\n            };\r\n\r\n            req.send(null);            \r\n        });\r\n    }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Binary/Binary.js","import GfxObject from 'Object/Object';\r\nimport Input from 'Input/InputManager';\r\nimport Deferred from 'Core/Deferred';\r\n\r\n\t/*jshint devel: true, bitwise: false*/\r\n    /**\r\n     * This class extends {GfxObject} to implement 2D sprites using an image sprite sheet.\r\n     * \r\n     * A sprite can have an infinite number of animations.\r\n     * Each animation can have a different frameDuration and any number of frames.\r\n     * Each frame may have a different size and a different hitbox\r\n     * \r\n     * @param {String} type An identifier for this sprite, can be for example `enemy1`,...\r\n     * @param {Object} options An options hash for the object\r\n     * @param {String} options.imageSrc The path to the spritesheet image\r\n     * @param {Object} options.animations An hash with a key for each animation of the sprite.\r\n     * \r\n     * @note Since games usually have multiple sprites of the same type, it's common to extend the Sprite class\r\n     * to generate each sprite type with its own properties and then use these sprites instead of instanciating\r\n     * the Sprite class but it's possible to do so.\r\n     * \r\n     * @example\r\n     * \r\n     * let mySprite = new Sprite('gem', {\r\n\t *  imageSrc: 'objects',\r\n\t *  x: options.x,\r\n\t *  y: options.y,\r\n\t *  pool: options.pool,\r\n\t *  canCollide: true,\r\n\t *  collideGroup: 1,\r\n\t *  animations: {\r\n\t *      mainLoop: {\r\n\t *          frameDuration: 4,\r\n\t *          frames:[{\r\n\t *              offsetX: 136,\r\n\t *              offsetY: 189,\r\n\t *              w: 31,\r\n\t *              h: 31,\r\n\t *              hitBox: {\r\n\t *                  x: 0,\r\n\t *                  y: 0,\r\n\t *                  x2: 31,\r\n\t *                  y2: 31\r\n\t *              },\r\n\t *              plane: 0\r\n\t *          },\r\n     *               {\r\n\t *              offsetX: 170,\r\n\t *              offsetY: 189,\r\n\t *              w: 31,\r\n\t *              h: 31,\r\n\t *              hitBox: {\r\n\t *                  x: 0,\r\n\t *                  y: 0,\r\n\t *                  x2: 31,\r\n\t *                  y2: 31\r\n\t *              },\r\n\t *              plane: 0\r\n\t *          }],\r\n     *           loop: 1\r\n\t *       }\r\n     *    }\r\n     * });\r\n     * \r\n     * @related {GfxObject}\r\n     */\r\n    class Sprite extends GfxObject{\r\n\t\tconstructor(type, options) {\r\n\t\t\tsuper(type || 'Sprite', options || {});\r\n\r\n\t\t\tthis.imageSrc = options && options.imageSrc || '';\r\n\r\n            // NOTE: sometimes it is done by gfxobject.reset(), sometimes not\r\n            // animations can now be added later\r\n            if (options && options.animations) {\r\n                this.load(options.animations);\r\n            }\r\n\t\t}\r\n\r\n        /**\r\n         * Init default sprite properties\r\n         */\r\n      initProperties() {\r\n\t\t\tthis.animations = {};\r\n\t\t\t// frames\r\n\t\t\tthis.currentAnim = null;\r\n\t\t\tthis.currentFrame = null;\r\n\t\t\tthis.currentFrameNum = this.previousFrameNum = 0;\r\n            this.loaded = false;\r\n\r\n            this.currentAnimName = '';\r\n\r\n            this.storedAnimName = '';\r\n            this.storedFrameNum = 0;\r\n\r\n\t\t\tthis.numFrames = 0;\r\n\t\t\tthis.rewindOnEnd = false;\r\n\t\t\tthis.direction = 1;\r\n\r\n\t\t\tthis.frameCounter = 0;\r\n\r\n            // end animation defered\r\n            this.animEndDef = null;\r\n            this.animChangeDef = null;\r\n\r\n            // holds a reference to the dom image object from which sprite will be blitted\r\n            // this.image = null;\r\n\r\n            this.rewinded = false;\r\n\r\n\t\t\tthis.isDebug = false;\r\n        }\r\n\r\n        /**\r\n         * Toggles debugging\r\n         * \r\n         * @param {Boolean} isDebug wether to enable or disable debug\r\n         * \r\n         * TODO: should use a global setting instead\r\n         * \r\n         * @private\r\n         */\r\n\t\tdebug(isDebug) {\r\n\t\t\tthis.isDebug = isDebug;\r\n\t\t}\r\n        \r\n        /**\r\n         * Resets the sprite to its default settings\r\n         */\r\n        reset() {\r\n           super.reset();\r\n        }\r\n\r\n        /**\r\n         * Adds a new animation to the sprite\r\n         * \r\n         * @param {String} name The name of the new animation\r\n         * @param {String} source The source of the image\r\n         * @param {Object} options The animation to add, see:\r\n         * @param {number=0} options.offsetX The x offset of the sprite frames inside the image\r\n         * @param {number=0} options.offsetY The y offset of the sprite frames inside the image*\r\n         * @param {number} options.frameWidth The width of a frame\r\n         * @param {number=imageHeight} options.frameHeight The height of a frame. By default frameHeight is taken from image.naturalHeight\r\n         * @param {number=1} options.frameDuration The duration of a frame (1 = 16ms)\r\n         * @param {number=0} options.frameSpacing The space between each frame\r\n         * @param {number=1} options.loop 0=anim play once and stops at the end, 1=anim loops to frame 1 at the end, 2=anim will play in reverse when reaching the end, then plays again, etc\r\n         * @returns {Deferred} a deferred object that's resolved once the animation is ready\r\n         * @example\r\n         * // creates a new animation from the image run.png\r\n         * mySprite.addAnimation ('running', 'run.png', {\r\n         *    frameWidth: 32\r\n         * })\r\n         */\r\n        addAnimation(name, source, options = {}) {\r\n            let animations = {},\r\n                def = new Deferred(),\r\n                img = new Image();\r\n\r\n            animations[name] = Object.assign({\r\n                frameDuration: 1,\r\n                loop: 1,\r\n                frames: []\r\n            }, options);\r\n\r\n            this.imageSrc = img.src = source;\r\n            this.setImage(img);\r\n\r\n            img.onload = function() {\r\n                let x = options.offsetX || 0,\r\n                    y = options.offsetY || 0,\r\n                    frames = animations[name].frames,\r\n                    frameHeight = options.frameHeight || this.naturalHeight,\r\n                    frameSpace = options.frameWidth + (options.frameSpacing || 0);\r\n\r\n                while(x < this.naturalWidth) {\r\n                    frames.push({\r\n                        offsetX: x,\r\n                        offsetY: y,\r\n                        w: options.frameWidth,\r\n                        h: frameHeight,\r\n                        hitBox: {\r\n                            x: 0,\r\n                            y: 0,\r\n                            x2: options.frameWidth - 1,\r\n                            y2: frameHeight - 1\r\n                        }\r\n                    });\r\n                    x += frameSpace;\r\n                }\r\n\r\n                def.resolve();\r\n                    \r\n            }.bind(img);\r\n\r\n            def.promise.then(() => {\r\n                this.load(animations);\r\n            });\r\n\r\n            return def.promise;\r\n        }\r\n\r\n        /**\r\n         * Loads animations from settings, flipping sprites if needed\r\n         * and sets the last animation of the array as current animation\r\n         * \r\n         * \r\n         */\r\n\t\tload(anims) {\r\n            if (!this._settings)\r\n                debugger;\r\n                \r\n            let animations = anims || this._settings.animations,\r\n                lastName;\r\n\r\n            if (!this.loaded) {\r\n                this.initProperties();\r\n\r\n                this.loaded = true;\r\n\r\n                Object.keys(animations).forEach((name) => {\r\n                    let animation = animations[name];\r\n                    this.animations[name] = animation;\r\n                    lastName = name;\r\n                    // handle flip of sprites\r\n                    if (animation.flipFrom) {\r\n                        this.updateFlipAnimation(animation, animation.flipFrom, animation.flipType);\r\n                    }                    \r\n                })\r\n\r\n                // by default, the last animation becames the current one\r\n                this.setAnimation(lastName);\r\n            } else {\r\n                // debugger;\r\n                // console.warn('attempt to load already loaded animations');\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * WIP: updateFlipAnimation\r\n         * \r\n         * It's possible to define a new animation that is simply the flip of another one\r\n         * This method copies the frames of the source animation and flips them\r\n         * \r\n         * @param {Object} animation The animation to create frames for\r\n         * @param {String} flipFrom The name of the animation to use as reference\r\n         * @param {Number} flipType The direction of the flip: set to 1 for left/right flip, 2 for top/bottom flip\r\n         * \r\n         */\r\n        updateFlipAnimation(anim, flipFrom, flipType) {\r\n            let animFromFrames = this.animations[flipFrom].frames;\r\n\r\n            // copy frames from source animation (keeping references)\r\n            anim.frames = new Array(animFromFrames.length);\r\n\r\n            // right now, flip animations only contain the flipType: 1 = horiz, 2 = vert, 3 = both\r\n            // we only need to define hitBoxes\r\n            for (let i = 0; i < animFromFrames.length; ++i) {\r\n                anim.frames[i] = {};\r\n                // $.extend(true, anim.frames[i], animFromFrames[i]);\r\n                Object.assign(anim.frames[i], animFromFrames[i]);\r\n                if (flipType & 1) {\r\n                    anim.frames[i].hitBox.x = animFromFrames[i].w - animFromFrames[i].hitBox.x2;\r\n                    anim.frames[i].hitBox.x2 = animFromFrames[i].w - animFromFrames[i].hitBox.x;\r\n                }\r\n                if (flipType & 2) {\r\n                    anim.frames[i].hitBox.y = animFromFrames[i].h - animFromFrames[i].hitBox.y2;\r\n                    anim.frames[i].hitBox.y2 = animFromFrames[i].h - animFromFrames[i].hitBox.y;\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Changes the source image for this sprite\r\n         * \r\n         * @param {Image} image the new Image to use as spritesheet\r\n         */\r\n        setImage(image, force = false) {\r\n            if (this.image && !force) {\r\n                return;\r\n            }\r\n\r\n            this.image = image;\r\n\r\n            // set image for children as well, this means\r\n            // we assume children are using same image as parent\r\n            // and this is BAD! ;)\r\n            this.children.forEach((child) => {\r\n                child.setImage(image);\r\n            });\r\n        }\r\n        \r\n        /**\r\n         * Plays the animation from the end up to the first frame\r\n         */\r\n        rewind() {\r\n            this.direction = -this.direction;\r\n            this.running = true;\r\n            this.rewinded = true;\r\n            this.nextFrame();\r\n            console.log('[Sprite] rewind', this.currentFrameNum, this.running, this.rewinded, this.direction);\r\n        }\r\n        \r\n        /**\r\n         * Goes to the next animation frame\r\n         * \r\n         * When reaching the last frame, the next frame will depend on animation.loop property:\r\n         * \r\n         * - if loop == 2 then animation will play back in reverse mode, up to the first frame\r\n         * - if loop == 1 then animation will play back from the begining so nextFrame = 0\r\n         * - if loop == 0/undefined then animation will stop and sprite._onAnimateEnd is called\r\n         */\r\n\t\tnextFrame() {\r\n            if (!this.running) {\r\n                return;\r\n            }\r\n\r\n            this.currentFrameNum += this.direction;\r\n\r\n            if (this.currentFrameNum < 0 || this.currentFrameNum >= this.numFrames) {\r\n                switch(this.currentAnim.loop) {\r\n                    // reverse loop\r\n                    case 2:\r\n                        this.direction = -this.direction;\r\n                        this.currentFrameNum = (this.currentFrameNum < 0) ? 0 : this.numFrames - 1;\r\n                        this.currentFrame = this.currentAnim.frames[this.currentFrameNum];\r\n                        break;\r\n\r\n                    case 1:\r\n                        this.currentFrameNum =  this.currentAnim.loopFrom ? this.currentAnim.loopFrom : 0;\r\n                        this.currentFrame = this.currentAnim.frames[this.currentFrameNum];\r\n                        break;\r\n\r\n                    // no loop: end of animation\r\n                    default:\r\n                        // console.log('stop running animation', this.type);\r\n                        if (!this.currentAnim.rewindOnEnd || this.rewinded) {\r\n                            // since we stoped, it means currentFrameNum is out of bounds\r\n                            // so we need to get it to the last inbound value to avoid crash\r\n                            // if store/restore is used\r\n                            this.currentFrameNum -= this.direction;\r\n\r\n                            this.running = false;\r\n                            // console.log('call on Animation ended, rewinded or did not need to');\r\n                            this._animationEnded();\r\n                        } else if (this.currentAnim.rewindOnEnd) {\r\n                            this.rewind();\r\n                        }\r\n                        break;\r\n                }\r\n            } else {\r\n                this.currentFrame = this.currentAnim.frames[this.currentFrameNum];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Save current animation name and frame for later use\r\n         */\r\n        storeCurrentAnim() {\r\n            this.storedAnimName = this.currentAnimName;\r\n            this.storedFrameNum = this.currentFrameNum;\r\n        }\r\n        \r\n        /**\r\n         * Restore animation to a previous saved state\r\n         * \r\n         * @related {restorePreviousAnim}\r\n         */\r\n        restorePreviousAnim() {\r\n            this.setAnimation(this.storedAnimName, null, this.storedFrameNum);\r\n        }\r\n        \r\n        /**\r\n         * advanceFrame is called at each render loop and waits for currentAnim.frameDuration\r\n         * before advancing to the next animation frame.\r\n         * \r\n         * If animName != than currentAnimName then switches to the new animation\r\n         */\r\n\t\tadvanceFrame(animName) {\r\n            this.previousFrameNum = this.currentFrameNum;\r\n\r\n\t\t\tif (this.currentAnim !== this.animations[animName]) {\r\n\t\t\t\tthis.frameCounter = 0;\r\n\t\t\t\tthis.setAnimation(animName);\r\n\t\t\t} else {\r\n\t\t\t\tif (++this.frameCounter > this.currentAnim.frameDuration) {\r\n\t\t\t\t\tthis.nextFrame();\r\n\t\t\t\t\tthis.frameCounter = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the width of the current animation frame\r\n         */\r\n\t\tgetCurrentWidth() {\r\n            // TODO: handle scale/rotate ?\r\n            return this.currentFrame.w;\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the height of the current animation frame\r\n         */\r\n\t\tgetCurrentHeight() {\r\n            // TODO: handle scale/rotate ?\r\n\t\t\treturn this.currentFrame.h;\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the x offset in the spritesheet of current animation frame\r\n         * \r\n         * @returns {number} current frame horizontal offset in the spritesheet\r\n         */\r\n\t\tgetCurrentOffsetX() {\r\n\t\t\treturn this.currentFrame.offsetX;\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the y offset in the spritesheet of current animation frame\r\n         * \r\n         * @returns {number} current frame vertical offset in the spritesheet\r\n         */\r\n\t\tgetCurrentOffsetY() {\r\n\t\t\treturn this.currentFrame.offsetY;\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the optional horizontal shift of the sprite: can be used\r\n         * if sprite image's width is less than actual frame width and sprite is flipped\r\n         * \r\n         * @returns {number} current frame horizontal shift value or 0 if not defined\r\n         * \r\n         * @private\r\n         */\r\n\t\tgetCurrentShiftX() {\r\n\t\t\treturn this.currentFrame.shiftX || 0;\r\n\t\t}\r\n\r\n        /**\r\n         * Returns the optional horizontal shift of the sprite: can be used\r\n         * if sprite image's height is less than actual frame height and sprite is flipped\r\n         * \r\n         * @returns {number} current frame vertical shift value or 0 if not defined\r\n         * \r\n         * @private\r\n         */        \r\n\t\tgetCurrentShiftY() {\r\n\t\t\treturn this.currentFrame.shiftY || 0;\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the hitBox of current animation frame\r\n         * \r\n         * @returns {Object} the hitbox\r\n         * \r\n         * @example\r\n         * \r\n         * { x: 0, y: 0, x2: 10, y2: 10 }\r\n         */\r\n        getHitBox() {\r\n            return this.currentFrame.hitBox;\r\n        }\r\n        \r\n        /**\r\n         * Centers the sprite horizontaly around a tile\r\n         * \r\n         * @param {Object} tilePos The tile to center the sprite on\r\n         */\r\n        centerXOverTile(tilePos) {\r\n            let tileWidth = this.currentMap.tileWidth,\r\n                currentWidth = this.getCurrentWidth(),\r\n                // currentWidth = this.getHitBox().x2 - this.getHitBox().x,\r\n                shift = Math.floor((tileWidth - currentWidth) / 2);\r\n\r\n            if (currentWidth <= tileWidth) {\r\n                this.x = (tilePos.x * tileWidth) + shift;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Stops current animation from running\r\n         * \r\n         * TODO: rename this method\r\n         */\r\n        clearMove() {\r\n            this.running = false;\r\n            // super.clearMove();\r\n        }\r\n        \r\n        /**\r\n         * Changes the sprite's current animation\r\n         * \r\n         * @param {String} anim The new animation to play.\r\n         * @param {Function=undefined} fn An optionnal callback to run when the animation will have ended.\r\n         * @param {number=0} frameNum The first frame to play, defaults to zero.\r\n         * @param {Boolean=false} rever Wether to start playing the animation from the last frame\r\n         */\r\n\t\tsetAnimation(anim, fn, frameNum, revert) {\r\n\t\t\t// console.log('[Sprite] setting animation of', this.type, 'to', anim);\r\n            // load animations if not loaded\r\n            if (!this.loaded) {\r\n                this.load();\r\n            }\r\n\r\n\t\t\ttry{\r\n\t\t\t\tif (this.currentAnim) {\r\n\t\t\t\t\tthis._animationEnded();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.animEndDef = new Deferred();\r\n\r\n\t\t\t\tif (this.currentAnim) {\r\n\t\t\t\t\tthis._animationChanged(this.currentAnimName, anim);\r\n\t\t\t\t}\r\n\r\n                this.animChangeDef = new Deferred();\r\n\r\n\t\t\t\tthis.currentAnim = this.animations[anim];\r\n                this.currentAnimName = anim;\r\n\t\t\t\tthis.numFrames = this.currentAnim.frames.length;\r\n\r\n                this.currentFrameNum = this.previousFrameNum = !revert ? frameNum || 0 : this.numFrames - 1;\r\n\t\t\t\tthis.currentFrame = this.currentAnim.frames[this.currentFrameNum];\r\n\r\n                // animation running\r\n                this.running = true;\r\n\r\n                this.rewinded = false;\r\n\r\n                // we need to reset direction in case we were rewinding\r\n                this.direction = revert ? -1 : 1;\r\n\r\n                // add end animation callback if specified\r\n\t\t\t\tif (typeof fn === 'function') {\r\n\t\t\t\t\tthis.onAnimationEnd(fn);\r\n\t\t\t\t}\r\n\t\t\t} catch(err) {\r\n                debugger;\r\n\t\t\t\tconsole.error('[Sprite] setAnimation() - unable to set animation ', anim, '(' + err.message + ')', 'for sprite', this.id);\r\n\t\t\t}\r\n\t\t}\r\n        \r\n        /**\r\n         * Stops playing current animation\r\n         * \r\n         * @param {Boolean} runPreviousEndMethod Set to false if you don't want to run the end callback functions\r\n         */\r\n        stopAnimation(runPreviousEndMethod) {\r\n            this.running = false;\r\n\r\n            // do not run end callbacks if animation has been interrupted before\r\n            // reaching the end\r\n            if (this.animEndDef && !runPreviousEndMethod) {\r\n                this.animEndDef.reject();\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Starts/resumes animation playback\r\n         * \r\n         * This method only sets `this.running` to true.\r\n         */\r\n        startAnimation() {\r\n            this.running = true;\r\n        }\r\n        \r\n        /**\r\n         * Adds a new function that will be called when current animation ends\r\n         * \r\n         * @param {Function} fn The callback to run\r\n         */\r\n        onAnimationEnd(func) {\r\n            // console.log(this.currentAnimName, 'animationEnd');\r\n            this.animEndDef.promise.then(func.bind(this));\r\n        }\r\n        \r\n        /**\r\n         * Adds a new function that will be called when a new animation is ran\r\n         * \r\n         * @param {Function} func The callback function to add.\r\n         */\r\n        onAnimationChange(func) {\r\n            this.animChangeDef.promise.then(func.bind(this));\r\n        }\r\n        \r\n        /**\r\n         * Runs every registered end callback function\r\n         * \r\n         * @private\r\n         */\r\n        _animationEnded() {\r\n    // console.log('animationEnd', this.currentAnimName);\r\n            this.animEndDef.resolve(this.currentAnimName, this.currentFrameNum);\r\n        }\r\n\r\n        /**\r\n         * Runs every registered change callback function\r\n         * \r\n         * @private\r\n         */\r\n        _animationChanged(oldAnim) {\r\n            this.animChangeDef.resolve(oldAnim, this.currentAnimName);\r\n        }\r\n        \r\n        /**\r\n         * onHit is called when a collision has been detect between the sprite and another graphical object\r\n         * \r\n         * @param {GfxObject} obj The graphical object that collided\r\n         */\r\n\t\tonHit(obj) {\r\n            super.onHit(obj);\r\n\t\t\tconsole.log('[Sprite] oops, ', this.type, ' [', this.id, '] ', 'was hit by', obj.name, ' [', obj.id, ']');\r\n\t\t}\r\n        \r\n        /**\r\n         * Draws the sprite onto the canvas context passed\r\n         * \r\n         * @param {CanvasContext} destCtx The context where to render the sprite.\r\n         * @param {Boolean=false} debug wether to show the sprite hit box\r\n         * \r\n         * @private\r\n         */\r\n        draw(destCtx, debug) {\r\n            if (!this.visible) {\r\n                return;\r\n            }\r\n\r\n            // auto goto next frame\r\n            if (this.currentAnimName.length) {\r\n                this.advanceFrame(this.currentAnimName);\r\n            }\r\n\r\n            let w = this.getCurrentWidth(),\r\n                scaledW = w * this.scale,\r\n                h = this.getCurrentHeight(),\r\n                scaledH = h * this.scale,\r\n                subScaledW = (scaledW/2) | 0,\r\n                subScaledH = (scaledH/2) | 0,\r\n                x = this.getCurrentOffsetX(),\r\n                y = this.getCurrentOffsetY(),\r\n                drawX = this.currentAnim.flipFrom ? (this.x + this.getCurrentShiftX() - scaledW): (this.x + this.getCurrentShiftX()),\r\n                drawY = this.currentAnim.flipFrom ? (this.y + this.getCurrentShiftY() - scaledH) : (this.y + this.getCurrentShiftY()),\r\n                mapOffsetX = this.currentMap && this.currentMap.viewportX || 0,\r\n                mapOffsetY = this.currentMap && this.currentMap.viewportY || 0;\r\n\r\n            // if width or height equals to 0 we may skip drawing\r\n            // this fixes IndexSizeError in Firefox\r\n            if (!w || !h) {\r\n                return;\r\n            }\r\n\r\n            // TODO: fix map position when rotate is used\r\n            if (this.isFxQueueEmpty()) {\r\n                if (this.currentAnim.flipFrom) {\r\n                    destCtx.save();\r\n                    destCtx.scale((this.currentAnim.flipType & 1) ? -1 : 1, (this.currentAnim.flipType & 2) ? -1 : 1);\r\n                    // console.log('drawing to', drawX + mapOffsetX, drawY + mapOffsetY);\r\n                }\r\n\r\n                try{\r\n                    destCtx.drawImage(this.image, Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h), Math.floor(drawX + mapOffsetX), Math.floor(drawY + mapOffsetY), Math.floor(scaledW), Math.floor(scaledH));\r\n                } catch(e) {\r\n                    debugger;\r\n                }\r\n\r\n                if (this.currentAnim.flipFrom) {\r\n                    destCtx.restore();\r\n                }\r\n\r\n                if (this.isDebug === true  || debug === true) {\r\n                    this.showHitBox(destCtx);\r\n                }\r\n            } else {\r\n                this.executeFx(destCtx);\r\n\r\n                // translate to keep the object as its position\r\n                destCtx.save();\r\n                // flip\r\n                if (this.currentAnim.flipFrom) {\r\n                    destCtx.scale((this.currentAnim.flipType & 1) ? -1 : 1, (this.currentAnim.flipType & 2) ? -1 : 1);\r\n                }\r\n                destCtx.translate(drawX + mapOffsetX + subScaledW, drawY + mapOffsetY + subScaledH);\r\n                destCtx.rotate(this.angle);\r\n                destCtx.drawImage(this.image, x, y, w, h, -subScaledW, -subScaledH, scaledW, scaledH);\r\n                destCtx.restore();\r\n                if (this.isDebug === true  || debug === true) {\r\n                    this.showHitBox(destCtx);\r\n                }\r\n            }\r\n\r\n            if (this.children.length) {\r\n                this.children.forEach((sprite) => {\r\n                    sprite.draw(destCtx, debug);\r\n                });\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Draws the sprite hit box\r\n         * \r\n         * @param {CanvasContext} The canvas context where to render the hitbox\r\n         */\r\n\t\tshowHitBox(ctx) {\r\n\t\t\t// TODO: add scale (rotation ?)\r\n\t\t\tlet hitBox = this.getHitBox(),\r\n\t\t\t\tmapOffsetX = this.currentMap && this.currentMap.viewportX || 0,\r\n\t\t\t\tmapOffsetY = this.currentMap && this.currentMap.viewportY || 0;\r\n\r\n            if (!hitBox) {\r\n                return;\r\n            }\r\n\r\n\t\t\tctx.strokeStyle = 'rgb(0,230,0)';\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(hitBox.x + this.x + mapOffsetX, hitBox.y + this.y + mapOffsetY);\r\n\t\t\tctx.lineTo(hitBox.x2 + this.x + mapOffsetX, hitBox.y + this.y + mapOffsetY);\r\n\t\t\tctx.lineTo(hitBox.x2 + this.x + mapOffsetX, hitBox.y2 + this.y + mapOffsetY);\r\n\t\t\tctx.lineTo(hitBox.x + this.x + mapOffsetX, hitBox.y2 + this.y + mapOffsetY);\r\n\t\t\tctx.lineTo(hitBox.x + this.x + mapOffsetX, hitBox.y + this.y + mapOffsetY);\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n        \r\n        /**\r\n         * Draws all sprite animation frames onto a temporary canvas that is added to the body tag\r\n         * \r\n         * This is used for debugging sprites\r\n         *\r\n         * @private\r\n         */\r\n\t\tdescribeAllAnimations() {\r\n\t\t\tlet animation = null,\r\n\t\t\t\tthat = this,\r\n\t\t\t\tdestX = 1,\r\n\t\t\t\tdestY = 1,\r\n\t\t\t\tanimationName = '',\r\n\t\t\t\twidth = 0,\r\n\t\t\t\theight = 0,\r\n\t\t\t\ttotalWidth = 0,\r\n\t\t\t\ttotalHeight = 0,\r\n                canvas,\r\n\t\t\t\tctx = null;\r\n\r\n\t\t\tObject.keys(this.animations).forEach((animationName) => {\r\n\t\t\t\tanimation = this.animations[animationName];\r\n\t\t\t\twidth = animation.frames[0].w;\r\n\t\t\t\theight = animation.frames[0].h;\r\n\r\n\t\t\t\tif ((width + 5) * animation.frames.length > totalWidth) {\r\n\t\t\t\t\ttotalWidth = (width + 5) * animation.frames.length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttotalHeight += (height + 5);                \r\n            });\r\n\r\n            canvas = document.getElementById('describe');\r\n\r\n            if (!canvas) {\r\n                canvas = document.createElement('canvas');\r\n                canvas.id = 'describe';\r\n                canvas.setAttribute('width', totalWidth);\r\n                canvas.setAttribute('height', totalHeight);\r\n                canvas\r\n            }\r\n            debugger;\r\n            ctx = new Dom('#describe')[0] && new Dom('#describe')[0].getContext('2d') || new Dom('canvas').attr('id', 'describe').attr('width', totalWidth).attr('height', totalHeight).css('zIndex', '100').appendTo('body')[0].getContext('2d');\r\n\r\n            ctx.webkitImageSmoothingEnabled = false;\r\n\r\n\t\t\tObject.keys(this.animations).forEach((animationName) => {\r\n\t\t\t\tdestX = 1;\r\n\r\n\t\t\t\tanimation = this.animations[animationName];\r\n\t\t\t\tconsole.log(animationName, 'got', animation.frames.length);\r\n\t\t\t\tconsole.log('frameDuration=', animation.frameDuration);\r\n\t\t\t\tconsole.log('loop=', animation.loop);\r\n\t\t\t\tconsole.log('loopFrom=', animation.loopFrom);\r\n\t\t\t\tconsole.log('rewindOnEnd', animation.rewindOnEnd);\r\n\r\n\t\t\t\tanimation.frames.forEach((frame, i) => {\r\n\t\t\t\t\tvar w = frame.w,\r\n\t\t\t\t\t\th = frame.h,\r\n\t\t\t\t\t\tx = frame.offsetX,\r\n\t\t\t\t\t\ty = frame.offsetY,\r\n\t\t\t\t\t\thitBox = frame.hitBox;\r\n\r\n\t\t\t\t\t// Draw sprite image\r\n\t\t\t\t\tctx.drawImage(that.image, x, y, w, h, destX, destY, w, h);\r\n\r\n\t\t\t\t\t/* Draw frame around sprite */\r\n\t\t\t\t\tctx.strokeStyle = 'rgb(240,240,240)';\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(destX - 1, destY - 1);\r\n\t\t\t\t\tctx.lineTo(destX + w, destY - 1);\r\n\t\t\t\t\tctx.lineTo(destX + w, destY + h + 1);\r\n\t\t\t\t\tctx.lineTo(destX - 1, destY + h + 1);\r\n\t\t\t\t\tctx.lineTo(destX - 1, destY - 1);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t\tctx.lineCap = 'butt';\r\n\t\t\t\t\tctx.stroke();\r\n\r\n\t\t\t\t\t// draw hitBox\r\n                    if (hitBox) {\r\n                        ctx.strokeStyle = 'rgb(0,230,0)';\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(destX + hitBox.x, destY + hitBox.y);\r\n                        ctx.lineTo(destX + hitBox.x2, destY + hitBox.y);\r\n                        ctx.lineTo(destX + hitBox.x2, destY + hitBox.y2);\r\n                        ctx.lineTo(destX + hitBox.x, destY + hitBox.y2);\r\n                        ctx.lineTo(destX + hitBox.x, destY + hitBox.y);\r\n                        ctx.closePath();\r\n                        ctx.stroke();\r\n                    }\r\n\r\n\t\t\t\t\tdestX += width + 5;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdestY += height + 5;\r\n\t\t\t});\r\n\t\t}\r\n        \r\n        /**\r\n         * Returns the sprite's animation hash\r\n         * \r\n         * Used for debugging\r\n         * \r\n         * @private\r\n         */\r\n\t\tlistAnimations() {\r\n\t\t\treturn this.animations;\r\n\t\t}\r\n\t};\r\n\r\n\texport default Sprite;\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Sprite.js","import GfxObject from 'Object/Object';\n\n    /*jshint devel: true, bitwise: false*/\n    /**\n     * Basic class for displaying text using Canvas\n     * \n     * @param {String} type The type of the graphic object\n     * @param {Object} options\n     * @param {String} [options.text=undefined] The initial text. Can be changed later using Text.setText().\n     * @param {Number} [options.w=0] The width of the text.\n     * @param {Number} [options.h=0] The height of the text.\n     * @param {String} [options.fontFace=\"Arial\"] The font to use to draw the text.\n     * @param {String} [options.fontStyle=\"normal\"] The style of the font.\n     * @param {String} [options.fontSize=\"18px\"] The size of the font.\n     * @param {String} [options.fontWeight=\"normal\"] The weight of the font.\n     * @param {String} [options.align=\"center\"] How to align the text when rendered.\n     * @param {String} [options.color=\"white\"] The color to use when rendering the text.\n     * \n     * @example\n     * \n     * let myText = new Text({\n     *  text: 'hello',\n     *  fontFace: 'Verdana',\n     *  fontStyle: 'bold',\n     *  fontSize: '24px'\n     * })\n     */\n    export default class Text extends GfxObject{\n        constructor(type = 'Text' + new Date().getTime(), options = {}) {\n            // type = type || 'Text' + new Date().getTime();\n            // options = options || {};\n\n            super(type, options);\n\n            this.fontFace = options.fontFace || 'Arial';\n            this.fontStyle = options.fontStyle || 'normal';\n            this.fontSize = options.fontSize || '18px';\n            this.fontWeight = options.fontWeight || 'normal';\n            this.align = options.align || 'center';\n            this.color = options.color || 'white';\n\n            this._setFont();\n\n            if (options.text) {\n                this.setText(options.text);\n            }\n\n            this.w = options.w || 0;\n            this.h = options.h || 0;\n        }\n        \n        /**\n         * TODO\n         * \n         * @private\n         */\n        moveWithSpline() {\n\n        }\n        \n        /**\n         * Change the size of the object\n         * \n         * @param {Number} w The width of the object.\n         * @param {Number} h The height of the object.\n         */\n        setSize(w, h) {\n            if (w !== null) {\n                this.w = w;\n            }\n\n            if (h !== null) {\n                this.h = h;\n            }\n        }\n        \n        /**\n         * Change the text of the object\n         * \n         * @param {String} text The new text.\n         * @param {String} [text='center'] Optional new alignment for the text.\n         */\n        setText(text, align) {\n            this.text = text;\n            this.align = align || 'center';\n        }\n        \n        /**\n         * Change the color of the object\n         * \n         * @param {String} color Thew new color to use, can be anything that is valid for the `color` *CSS* property.\n         */\n        setColor(color) {\n            this.color = color;\n        }\n\n        /**\n         * Returns the hitbox of the text object\n         * \n         * @returns {Object} The new hitbox\n         */\n        getHitBox() {\n            return {\n                x: 0,\n                y: 0,\n                x2: this.w,\n                y2: this.y\n            };\n        }\n\n        /**\n         * Returns the width of the text object\n         * \n         * @returns [Number] The object's width\n         */\n        getCurrentWidth() {\n            return this.w;\n        }\n\n        /**\n         * Returns the height of the text object\n         * \n         * @returns [Number] The object's height\n         */        \n        getCurrentHeight() {\n            return this.h;\n        }\n\n        /**\n         * Returns the horizontal offset of the text object\n         * \n         * @returns [Number] The object's horizontal offset\n         */\n        getCurrentOffsetX() {\n            return this.offsetX;\n        }\n\n        /**\n         * Returns the vertical offset of the text object\n         * \n         * @returns [Number] The object's vertical offset\n         */\n        getCurrentOffsetY() {\n            return this.offsetY;\n        }\n\n        /**\n         * Called when an object collides with the text Object\n         * \n         * @param {GfxObject} obj The graphical object that collided.\n         */\n        onHit(obj) {\n            super.onHit(obj);\n            console.log('oops, ', this.type, ' [', this.id, '] ', 'was hit by', obj.name, ' [', obj.id, ']');\n        }\n\n        /**\n         * Called on each render loop: renders the object on the destination canvas context\n         * \n         * @param {CanvasContext} destCtx Where to render the object.\n         * \n         * @private\n         */\n        draw(destCtx) {\n            if (!this.visible) {\n                return;\n            }\n\n            destCtx.fillStyle = this.color;\n            destCtx.font = this.font;\n            destCtx.textBaseline = 'top';\n\n            if (this.angle !== 0) {\n                destCtx.save();\n                destCtx.rotate(this.angle);\n            }\n\n            destCtx.fillText(this.text, this.x, this.y);\n\n            if (this.angle !== 0) {\n                destCtx.restore();\n            }\n\n//                var w = this.getCurrentWidth(),\n//\t\t\t\t\tscaledW = w * this.scale,\n//\t\t\t\t\th = this.getCurrentHeight(),\n//\t\t\t\t\tscaledH = h * this.scale,\n//\t\t\t\t\tx = this.getCurrentOffsetX(),\n//\t\t\t\t\ty = this.getCurrentOffsetY();\n//\n//\t\t\t\tdestCtx.drawImage(image, x, y, w, h, this.x, this.y, scaledW, scaledH);\n        }\n\n        /**\n         * Generates the font css property using current this.fontSize and this.fontFace\n         */\n        _setFont() {\n            this.font = this.fontSize + ' ' + this.fontFace;\n        }\n    };\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Text.js","    /**\n     * Pool support for AthenaJS\n     * \n     * This objects allows to defined and use pools for any type of object\n     */\n    export default {\n        /**\n         * Creates a new pool\n         * \n         * @param {Function} obj the constructor of the object to add a pool for\n         * @param {Number} suze the size of the pool\n         */\n        create: function(obj, size) {\n            obj._pool = [];\n            obj._poolMarker = 0;\n            obj._poolSize = 0;\n\n            let pool = obj._pool;\n\n            /*\n             * Get a new object from the pool\n             * \n             * -*Note* This method does not call new but gets a reference to an already created object\n             *  and calls its constructor.\n             * \n             *  @returns {Object} an instance of the object from the pool\n             * \n             */\n            obj.createFromPool = function() {\n                // expand the pool if we run out of objects\n                if (obj._poolSize <= obj._poolMarker) {\n                    obj.expandPool(10);\n                }\n\n                // get new object\n                let newObj = obj._pool[obj._poolMarker++];\n\n                // save its index\n                newObj._poolIndex = obj._poolMarker - 1;\n\n                // apply the constructor\n                obj.prototype.constructor.apply(newObj, arguments);\n\n                return newObj;\n            }\n\n            /*\n             * expands an already created pool\n             * \n             * ]@param {number} size the new size of the pool\n             */\n            obj.expandPool = function(size) {\n                var options = {\n                    pool: true\n                };\n\n                for (var i = pool.length, max = pool.length + size; i < max; i++) {\n                    pool.push(new obj(options));\n                };\n\n                obj._poolSize += size;\n            }\n\n            // TODO: test me\n            // TODO: call the object's destructor, if any (guess we'll need to add it)\n            // obj.__proto__.freeFromPool = function() {\n            obj.prototype.freeFromPool = function() {\n                if (obj._poolMarker > 0) {\n                    obj._poolMarker--;\n                }\n\n            \tlet end = pool[obj._poolMarker],\n            \t   endIndex = end._poolIndex;\n\n            \tpool[obj._poolMarker] = this;\n            \tpool[this._poolIndex] = end;\n\n            \tend._poolIndex = this._poolIndex;\n            \tthis._poolIndex = endIndex;\n            }\n\n            // initial expand of the pool\n            obj.expandPool(size);\n        }\n    };\n\n\n// WEBPACK FOOTER //\n// ./js/Core/Pool.js","import FX from 'FX/FX';\r\nimport Easing from 'FX/Easing/Easing';\r\nimport Deferred from 'Core/Deferred';\r\nimport Dom from 'Core/Dom';\r\n\r\n/*jshint devel: true*/\r\n/**\r\n * \r\n */\r\nclass Display {\r\n    constructor(options, target) {\r\n        console.log('[Display] Init()', options.name/*, options, target*/);\r\n\r\n        let prefix = (function () {\r\n            let styles = window.getComputedStyle(document.documentElement, ''),\r\n                pre = (Array.prototype.slice\r\n                    .call(styles)\r\n                    .join('')\r\n                    .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\r\n                )[1],\r\n                dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];\r\n            return {\r\n                dom: dom,\r\n                lowercase: pre,\r\n                css: '-' + pre + '-',\r\n                js: pre[0].toUpperCase() + pre.substr(1)\r\n            };\r\n        })();\r\n\r\n        this.layers = new Array(options.numLayers);\r\n\r\n        this.prefix = prefix.lowercase;\r\n\r\n        this.target = target || new Dom('div').attr('id', 'display_' + options.name).appendTo('body');\r\n        this.width = options.width;\r\n        this.height = options.height;\r\n\r\n        this.type = options.type || '2d';\r\n\r\n        this.fxCtx = null;\r\n\r\n        this._createLayers();\r\n\r\n        this.fxQueue = {\r\n            'pre': {},\r\n            'post': {}\r\n        };\r\n    }\r\n\r\n    getBuffer(w, h) {\r\n        let ctx = new Dom('canvas').attr({\r\n            width: w + 'px',\r\n            height: h + 'px'\r\n        })[0].getContext('2d');\r\n\r\n        ctx['imageSmoothingEnabled'] = false;\r\n\r\n        return ctx;\r\n    }\r\n\r\n    _createLayers() {\r\n        let i;\r\n\r\n        for (i = 0; i < this.layers.length; ++i) {\r\n            this.layers[i] = new Dom('canvas').addClass('layer_' + i).attr({\r\n                'width': this.width,\r\n                'height': this.height\r\n            }).css({\r\n                'width': this.width + 'px',\r\n                'height': this.height + 'px',\r\n                zIndex: i\r\n            }).appendTo(this.target)[0].getContext(this.type);\r\n\r\n            this.layers[i]['imageSmoothingEnabled'] = false;\r\n        }\r\n\r\n        this.fxCtx = new Dom('canvas').addClass('fx').attr({\r\n            'width': this.width,\r\n            'height': this.height\r\n        }).css({\r\n            'width': this.width + 'px',\r\n            'height': this.height + 'px',\r\n            zIndex: i + 1\r\n        }).appendTo(this.target)[0].getContext(this.type);\r\n\r\n        this.fxCtx['imageSmoothingEnabled'] = false;\r\n    }\r\n\r\n    clearScreen(ctx) {\r\n        if (0) {\r\n            // setting canvas width resets imageSmoothingEnable to true\r\n            ctx.canvas.width = ctx.canvas.width;\r\n\r\n            ctx['imageSmoothingEnabled'] = false;\r\n        } else {\r\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n        }\r\n    }\r\n\r\n    clearAllScreens() {\r\n        for (let i = 0; i < this.layers.length; ++i) {\r\n            this.clearScreen(this.layers[i]);\r\n        }\r\n\r\n        this.clearScreen(this.fxCtx);\r\n    }\r\n\r\n    renderScene(scene) {\r\n        this.clearScreen(this.fxCtx);\r\n\r\n        // execute pre fx\r\n        // TODO: here we have to make some hack to pre-render all buffers into a single one\r\n        // then aply fx on this one, then render this one onto for-most layer\r\n        this.executeFx(this.layers[0], null, scene, null, 'pre');\r\n\r\n        // TODO: all CTX ?\r\n        for (let i = 0; i < this.layers.length; ++i) {\r\n            this.layers[i].canvas.style.opacity = scene.getOpacity();\r\n        }\r\n\r\n        this.clearScreen(this.layers[1]);\r\n\r\n        scene.render(this.layers);\r\n\r\n        if (scene.hudScene) {\r\n            scene.hudScene.render(this.layers);\r\n        }\r\n\r\n        // TODO: here we have to make some hack to pre-render all buffers into a single one\r\n        // then apply fx on this one, then render this one onto for-most layer\r\n        /* HACK */\r\n        if (Object.keys(this.fxQueue['post']).length) {\r\n            this.clearScreen(this.fxCtx);\r\n            // merge all canvas into fxCtx one\r\n            for (let i = 0; i < this.layers.length; ++i) {\r\n                this.fxCtx.drawImage(this.layers[i].canvas, 0, 0);\r\n            }\r\n        }\r\n        /* HACK */\r\n        // execute pre fx\r\n        this.executeFx(this.fxCtx, this.fxCtx, scene, null, 'post');\r\n    }\r\n\r\n    prepareCanvas(resources) {\r\n        let context = null,\r\n            i = 0,\r\n            oldStyle = '';\r\n\r\n        for (i = 0; i < this.layers.length; ++i) {\r\n            context = this.layers[i];\r\n\r\n            oldStyle = context.canvas.style.display;\r\n            context.canvas.style.display = \"none\";\r\n\r\n            // NOTE: should we hide the canvas before?\r\n            resources.forEach(function (resource) {\r\n                if (resource.type === \"image\") {\r\n                    // NOTE: maybe drawing only 1px is enough?\r\n                    context.drawImage(resource.elt, 0, 0);\r\n                }\r\n            });\r\n\r\n            this.clearScreen(context);\r\n\r\n            context.canvas.style.display = oldStyle;\r\n        }\r\n    }\r\n\r\n    animate(fxName, options, context) {\r\n        console.log('animate');\r\n\r\n        var fxClass = FX.getEffect(fxName),\r\n            promise,\r\n            easing = options.easing || 'linear',\r\n            when = options.when || 'pre',\r\n            fx,\r\n            that = this;\r\n\r\n        options.context = context || this;\r\n        // console.log('animate', this.fxQueue);\r\n\r\n        if (typeof this.fxQueue[when][fxName] !== 'undefined') {\r\n            console.warn('Fx', fxName, 'already in progress, cannot execute twice');\r\n            let def = new Deferred();\r\n            def.resolve();\r\n            promise = def.promise;\r\n\r\n        } else if (!fxClass) {\r\n            console.warn('Fx', fxName, 'unknown: did you spell it correctly ?');\r\n        } else {\r\n            fx = new fxClass(options, this);\r\n            fx.setEasing(new FX.getEasing(easing));\r\n\r\n            promise = fx.start().then(function () {\r\n                console.log('effect ended, need to stop it', fxName);\r\n                delete that.fxQueue[when][fxName];\r\n            });\r\n            this.fxQueue[when][fxName] = fx;\r\n        }\r\n\r\n        return promise;\r\n    }\r\n\r\n    stopAnimate(/*fxName*/) {\r\n        console.log('TODO: need to stop animation');\r\n    }\r\n\r\n    executeFx(ctx, fxCtx, obj, time, when) {\r\n        var fxObject;\r\n\r\n        when = when || 'pre';\r\n\r\n        for (var fxName in this.fxQueue[when]) {\r\n            fxObject = this.fxQueue[when][fxName];\r\n            // console.log('processing fx', fxName, fxObject);\r\n\r\n            fxObject.process(ctx, fxCtx, obj, time);\r\n        }\r\n    }\r\n\r\n    clearDisplay() {\r\n        console.log('clearFX Queue');\r\n        this.fxQueue.pre = {};\r\n        this.fxQueue.post = {};\r\n\r\n        this.clearAllScreens();\r\n    }\r\n};\r\n\r\nexport default Display;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Display/Display.js","import Display from 'Display/Display';\n\n    /*jshint devel: true*/\n\t\tclass DisplayManager{\n\t\t\tconstructor(options) {\n\t\t\t\t  console.log('[DisplayManager] Init()'/*, options*/);\n\n                  this.displays = {};\n\t\t\t   }\n         \n            addDisplay(options, target) {\n                console.log('[Display Manager] adding display', options.name/*, 'with options', options*/);\n\n                this.displays[options.name] = new Display(options, target);\n\n                return this.displays[options.name];\n            }\n        \n            getDisplay(id) {\n                return this.displays[id];\n            }\n\t\t};\n\n    console.log('end DisplayManager');\n    export default new DisplayManager();\n\n\n\n// WEBPACK FOOTER //\n// ./js/Display/DisplayManager.js","import FX from 'FX/FX';\n\n\t/*jshint devel: true, bitwise: false*/\n\tvar Easing = {\n        //                     x,          t,             b,        c,          d\n        'easeInQuad': function(x, t, b, c, d) {\n            console.log('easeInQuad');\n            return c*(t/=d)*t + b;\n\t\t},\n        'easeOutBounce': function(x, t, b, c, d) {\n            if ((t/=d) < (1/2.75)) {\n                return c*(7.5625*t*t) + b;\n            } else if (t < (2/2.75)) {\n                return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;\n            } else if (t < (2.5/2.75)) {\n                return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;\n            } else {\n                return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;\n            }\n        },\n\t\t'swing': function(x, t, b, c, d) {\n            return 0.5-Math.cos(x*Math.PI)/2;\n\t\t}\n\t};\n\n    Object.keys(Easing).forEach((name) => FX.addEasing(name, Easing[name]));\n\nexport default Easing;\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Easing/Easing.js","import Tile from 'Map/Tile';\nimport Wave from 'Object/Wave';\nimport RM from 'Resource/ResourceManager';\nimport NM from 'Notification/NotificationManager';\nimport FX from 'FX/FX';\nimport MapEvent from 'Map/MapEvent';\nimport Deferred from 'Core/Deferred';\n\n/*jshint devel: true, bitwise: false*/\n\nwindow.maps = {};\n\n\n/**\n * The `Map` is used to display tile-based backgrounds. It is usually initialized using a buffer containing\n * tiles and tilebehaviors. It has a viewport so that only a part of the map can be displayed.\n * A map also contains objects that are added onto the map once the viewport reaches a `block`.\n * \n * @param {Object} options\n * @param {string} options.src The url to an image that will be used for the tiles\n * @param {number} options.tileWidth The width of a tile\n * @param {number} options.tileHeight The height of a tile\n * @param {number} options.width The full width of the map\n * @param {number} options.height The full height of the map\n * @param {number} options.viewportW The width of the viewport: it is usually the same as the game width\n * @param {number} options.viewportH The height of the viewport: it is usually the same as the game height\n * @param {ArrayBuffer} options.buffer The buffer containing width \\* height bytes container tile numbers followed by width*height bytes for the tile behaviors\n * @example\n * var map = new Map({\n *    src: 'mapTiles.jpg',\n *    tileWidth: 32,\n *    tileHeight 32,\n *    width: 800,\n *    height: 600,\n *    buffer: new ArrayBuffer(800*600*2)\n * })\n * \n */\nclass Map {\n\tconstructor(options) {\n\t\tthis.options = options;\n\n\t\t// image url used for the map graphic tiles\n\t\tthis.src = options.src;\n\n\t\t// tiles and map width\n\t\tthis.tileWidth = options.tileWidth || 64;\n\t\tthis.tileHeight = options.tileHeight || 32;\n\t\tthis.width = options.width || 1024;\n\t\tthis.height = options.height || 1024;\n\n\t\t// DEBUG: usually tiles are loaded from binary files and set as ArrayBuffer\n\t\t// but previously tiles could be set from a JSON text file\n\t\tthis.tiles = options.tiles && this._createTiles(options.tiles) || [];\n\n\t\tthis.triggers = options.triggers || {};\n\t\tthis.windows = options.windows || {};\n\n\t\t// defines viewport window: used for scrolling\n\t\tthis.viewportX = options.viewportX || 0;\n\t\tthis.viewportY = options.viewportY || 0;\n\t\tthis.viewportW = options.viewportW || 0;\n\t\tthis.viewportH = options.viewportH || 0;\n\n\t\t// when scrolling we set a new target and keep track of previous start x & y\n\t\tthis.viewportTargetX = this.viewportTargetY = this.viewportSpeedX = this.viewsportSpeedY = this.viewportStartX = this.viewportStartY = 0;\n\n\t\t/* Scroll Type 1 */\n\t\t// this.viewportLimitX = 230;\n\t\t// this.viewportCenterX = 10; // 207\n\n\t\t// this.viewportLimitY = 154;\n\t\t// this.viewportCenterY = 230;\n\n\t\t/* Scroll Type 2 */\n\t\t/* Scrolling specific: TODESCRIBE */\n\t\tthis.viewportLimitX = 230;\n\t\tthis.viewportCenterX = 307;\n\n\t\tthis.viewportLimitY = 154;\n\t\tthis.viewportCenterY = 230;\n\n\t\t/* / End Scrolltype */\n\t\tthis.scrollOffsetX = 0;\n\t\tthis.scrollOffsetY = 0;\n\n\t\tthis.scrollTileOffsetX = 0;\n\t\tthis.scrollTileOffsetY = 0;\n\n\t\tthis.viewportLimits = {\n\t\t\tx1: this.viewportLimitX,\n\t\t\tx2: this.viewportW - this.viewportLimitX,\n\t\t\ty1: this.viewportLimitY,\n\t\t\ty2: this.viewportLimitH - this.viewportLimitY\n\t\t};\n\n\t\t/* list of objects sorted by type for faster colision detection */\n\t\tthis.objects = [];\n\t\tthis.friendBullets = [];\n\t\tthis.enemies = [];\n\t\tthis.platforms = [];\n\n\t\tthis.name = options.name;\n\n\t\t// calculate the number of rows/cols depending on the viewport window\n\t\tthis._calcNumTiles(false);\n\n\t\t// sets map data buffer\n\t\tthis.setBuffer(options.buffer);\n\n\t\tthis.dataUrl = options.dataUrl;\n\t\t/*\n\t\t\t\tthis.map = options.map || new Array(this.numCols * this.numRows);\n                this.tileTypes = options.tileTypes || new Array(this.numCols * this.numRows);\n\t\t\t\t*/\n\n\t\tthis.reverse = false;\n\n\t\tthis.firstRow = this.lastRow = this.firstCol = this.lastCol = 0;\n\n\t\tthis.isDebug = false;\n\n\t\tthis.srcBitmap = null;\n\n\t\t// if map is being scrolled, should we scroll again ?\n\t\tthis.moving = false;\n\n\t\t// Easing function to use while moving viewport (scrolling)\n\t\t// See FX/Easing for a list of available easing functions\n\t\tthis.easing = FX.getEasing(options.easing || 'linear');\n\n\t\t// used when initiating a new scroll\n\t\tthis.startMoveTime = null;\n\t\t// scrollType 1\n\t\t// this.duration = 10;\n\t\t// scrollType 2\n\t\t// scrolling duration\n\t\tthis.duration = 800;\n\n\t\tthis.masterObject = null;\n\n\t\t// current viewport window\n\t\tthis.currentWindow = null;\n\n\t\t// start position of the master object\n\t\tthis.startX = options.startX || 0;\n\t\tthis.startY = options.startY || 0;\n\n\t\t// Debug: add current map to the global list of maps\n\t\twindow.maps[this.name] = this;\n\n\t\t// set mapEvent class\n\t\t// if (options.mapEventClass) {\n\t\t// \tthis.mapEvent = new options.mapEventClass(this);\n\t\t// } else {\n\t\t// \tthis.mapEvent = new MapEvent(this);\n\t\t// }\n\n\t\t// TODESCRIBE\n\t\tthis.mapEvent = new MapEvent(this);\n\n\t\t// flag that \n\t\tthis.isDirty = true;\n\t}\n\t\n\t/**\n\t * \n\t * Changes the start position using the master's current position: usually called when reaching a checkpoint\n\t * \n\t */\n\tsetStartXYFromMaster() {\n\t\tthis.startX = this.masterObject.x;\n\t\tthis.startY = this.masterObject.y;\n\t}\n\t\n\t/**\n\t * Resets the master's position to the map.startX/startY position & resets its animation state:\n\t * usually called when player loses a life and needs to be positionned at checkpoint\n\t * \n\t */\n\tresume() {\n\t\tconsole.log('avant', this.masterObject.running, this.masterObject.currentAnimName);\n\t\tthis.masterObject.reset();\n\t\tconsole.log('apres', this.masterObject.running, this.masterObject.currentAnimName);\n\t\tconsole.log('resuming', this.startX, this.startY);\n\n\t\tthis.masterObject.x = this.startX;\n\t\tthis.masterObject.y = this.startY;\n\t}\n\n\t\n\t/**\n\t * \n\t * Resets the map:\n\t * \t- removes objects from the map\n\t *  - reset windows\n\t *  - reset triggers\n\t *  - reset mapEvents\n\t *  - reset viewport + scrollOffset\n\t *  - sets isDirty to true so that map is redrawn\n\t * \n\t * TODO: scrollOffset shouldn't be 0 but depends on the master's position\n\t * \n\t */\n\treset() {\n\t\tthis.masterObject = null;\n\n\t\t// remove objects from the map and empty collision groups\n\t\tthis.objects.length = 0;\n\t\tthis.friendBullets.length = 0;\n\t\tthis.enemies.length = 0;\n\t\tthis.platforms.length = 0;\n\t\t// reset mapItems\n\n\t\t// reset windows\n\t\tfor (const id in this.windows) {\n\t\t\tthis.windows[id].displayed = false;\n\t\t}\n\n\t\t// reset triggers\n\t\tfor (const id in this.triggers) {\n\t\t\tthis.triggers[id].trigerred = false;\n\t\t}\n\n\t\t// reset mapEvent switches states too (fixes switch that automatically triggers)\n\t\tthis.mapEvent.reset();\n\n\t\t// and reset viewPort too\n\t\tthis.viewportX = this.options.viewportX || 0;\n\t\tthis.viewportY = this.options.viewportY || 0;\n\t\tthis.viewportW = this.options.viewportW || 0;\n\t\tthis.viewportH = this.options.viewportH || 0;\n\n\t\t// and scroll offset\n\t\tthis.scrollOffsetX = 0;\n\t\tthis.scrollOffsetY = 0;\n\n\t\tthis.scrollTileOffsetX = 0;\n\t\tthis.scrollTileOffsetY = 0;\n\n\t\tthis.firstCol = (-this.viewportX / this.tileWidth);\n\t\tthis.firstRow = (-this.viewportY / this.tileHeight);\n\n\t\tthis.lastCol = this.firstCol + this.numViewportCols;\n\t\tthis.lastRow = this.firstRow + this.numViewportRows;\n\n\t\tthis.isDirty = true;\n\t}\n\n\t\n\t/**\n\t * Sets the map tiles and tiletypes from binary buffer:\n\t *  - first (numCols * numRows) bytes are visual tile numbers\n\t *  - last (numCols * numRows) bytes are the tile types (wall, ladder,...)\n\t * \n\t * @param {any} buffer\n\t * \n\t */\n\tsetBuffer(buffer) {\n\t\tlet size = this.numCols * this.numRows;\n\n\t\tthis.map = new Uint8Array(buffer, 0, size);\n\t\tthis.tileTypes = new Uint8Array(buffer, size);\n\t}\n\n\t\n\t/**\n\t * Sets the master object, it will be used for:\n\t *  - scrolling the viewport when needed, centering it around the master sprite\n\t *  - collision detection\n\t * \n\t * @param {GfxObject} obj The object to set as master.\n\t * \n\t */\n\tsetMasterObject(obj) {\n\t\tthis.masterObject = obj;\n\n\t\t// position master object at map's startX/Y\n\t\t// TODO: use checkpoint instead\n\t\tobj.x = this.startX;\n\t\tobj.y = this.startY;\n\t}\n\n\t\n\t/**\n\t * Add a new graphical object on to the map, it will be:\n\t *  - displayed if it is visible (in the viewport)\n\t *  - added to collision group\n\t * \n\t * @param {GfxObject} obj A reference to the new object to add\n\t * \n\t * @note the object will be added to the correct collision group\n\t * if obj.collideGroup is set\n\t * \n\t */\n\taddObject(obj) {\n\t\tif (!obj.image) {\n\t\t\tobj.setImage(RM.getResourceById(obj.imageSrc));\n\t\t}\n\t\tobj.setMap(this);\n\n\t\tthis.objects.push(obj);\n\n\t\tif (obj.master === true) {\n\t\t\tthis.setMasterObject(obj);\n\t\t}\n\n\t\t// add element to collision group\n\t\tif (obj.collideGroup === 1) {\n\t\t\t// console.log('adding', obj.id, 'to enemies group!');\n\t\t\tthis.enemies.push(obj);\n\t\t} else if (obj.collideGroup === 2) {\n\t\t\t// console.log('adding', obj.id, 'to friend bullets group!');\n\t\t\tthis.friendBullets.push(obj);\n\t\t} else if (obj.collideGroup === 3) {\n\t\t\tconsole.log('adding platform', obj.id);\n\t\t\tthis.platforms.push(obj);\n\t\t} else {\n\t\t\tconsole.log('no collision or master for', obj.id);\n\t\t}\n\t\t/*\t\t\t\tif (obj.children.length) {\n\t\t\t\t\t\t\tfor (var i = 0; i < obj.children.length; i++) {\n\t\t\t\t\t\t\t\tthis.addObject(obj.children[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}*/\n\t}\n\n\t\n\t/**\n\t * Sets the map tile size (in pixels)\n\t * \n\t * @param {number} width of a map tile.\n\t * @param {number} height of a map tile.\n\t * \n\t */\n\tsetTilesSize(width, height) {\n\t\tthis.tileWidth = width;\n\t\tthis.tileHeight = height;\n\t}\n\n\t\n\t/**\n\t * changes current viewport size and position\n\t * \n\t * @param {number} x Horizontal position of the viewport.\n\t * @param {number} y Vertical position of the viewport.\n\t * @param {number} w Width of the viewport.\n\t * @param {number} h Height of the viewport.\n\t * \n\t * @note there is currently no boundaries checks\n\t * \n\t */\n\tsetViewPort(x, y, w, h) {\n\t\tthis.viewportX = x;\n\t\tthis.viewportY = y;\n\t\tthis.viewportW = w;\n\t\tthis.viewportH = h;\n\t}\n\n\t\n\t/**\n\t * Sets current debug status: when set to true outputs more console logs and may also debug visual stuff\n\t * like map tiles and objects onto the map\n\t * \n\t * @param {boolean} isDebug Set to true to enable debug.\n\t * \n\t */\n\tdebug(isDebug) {\n\t\tthis.isDebug = isDebug;\n\t\t// force tiles redraw at for next map render\n\t\tthis.isDirty = true;\n\t}\n\t\n\t/**\n\t * Move movable objects into the map\n\t * \n\t */\n\tmoveObjects() {\n\t\tthis.objects.forEach(function (obj) {\n\t\t\t// moving platforms must be moved before any other object\n\t\t\t// so they are moved in Map.movePlatforms() first\n\t\t\tif (obj.collideGroup !== 3) {\n\t\t\t\tobj.move();\n\n\t\t\t\t// TODO: set platform() if object reached a platform\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Move platform objects onto the map: they must be moved before normal objects are moved \n\t * so that movable objects move related to the platforms\n\t * \n\t */\n\tmovePlatforms() {\n\t\tthis.platforms.forEach(function (obj) {\n\t\t\tobj.move();\n\t\t});\n\t}\n\n\t\n\t/**\n\t * Handle moving map & its objects:\n\t *  - updates the viewport window if map.moving is set\n\t *  - checks for triggers (that could spawn new objects onto the map)\n\t *  - move platforms and objects\n\t * \n\t */\n\tmove() {\n\t\t\tlet currentTime = new Date().getTime(),\n\t\t\t\tellapsedTime = currentTime - this.startMoveTime,\n\t\t\t\tt = ellapsedTime / this.duration,\n\t\t\t\tmoveProgress;\n\n\t\t\t// TODO: handle end/begining of map reach\n\t\t\tif (this.moving === true) {\n\t\t\t\tif (ellapsedTime >= this.duration) {\n\t\t\t\t\tthis.moving = false;\n\t\t\t\t\tthis.viewportX = this.viewportTargetX;\n\t\t\t\t\tthis.viewportY = this.viewportTargetY;\n\t\t\t\t\t// TODO: send endMove event ?\n\t\t\t\t} else {\n\t\t\t\t\tmoveProgress = this.easing(t, ellapsedTime, 0, 1, this.duration);\n\n\t\t\t\t\t// console.log('moving', this.viewportX);\n\n\t\t\t\t\tthis.viewportX = this.viewportStartX + moveProgress * this.viewportSpeedX | 0;\n\t\t\t\t\tthis.viewportY = this.viewportStartY + moveProgress * this.viewportSpeedY | 0;\n\t\t\t\t}\n\t\t\t\tthis.isDirty = true;\n\t\t\t} else if (this.masterObject) {\n\t\t\t\t// TODO: this has nothing to do in this method!\n\t\t\t\tthis.checkMasterPosition();\n\t\t\t\tthis.checkForTriggers();\n\t\t\t}\n\n\t\t\t// first move platforms\n\t\t\tthis.movePlatforms();\n\n\t\t\t// then move normal objects\n\t\t\tthis.moveObjects();\n\t\t}\n\n\t\n\t/**\n\t * \n\t * Triggers map scrolling depending on the master's position (if needed)\n\t * \n\t */\n\tcheckMasterPosition() {\n\t\tlet destX = null,\n\t\t\tdestY = null;\n\t\t// TODO: adapt moveTo() ?\n\t\t// TODO: do not scroll left if we already see all of the map on the left\n\t\tif (this.masterObject && !this.moving) {\n\t\t\t// Scroll Type 1: continous\n\t\t\t// if (this.viewportX && ((this.masterObject.x + this.viewportX) < this.viewportLimitX)) {\n\t\t\t// \tdestX = this.viewportX + (this.viewportLimitX - (this.masterObject.x + this.viewportX)); // this.viewportCenterX;\n\t\t\t// } else if (((-this.viewportX + this.viewportW) - this.masterObject.x) < this.viewportLimitX) {\n\t\t\t// \tdestX = this.viewportX - (this.viewportLimitX - ((-this.viewportX + this.viewportW) - this.masterObject.x)); // this.viewportCenterX;\n\t\t\t// }\n\n\t\t\t// if (this.viewportY && ((this.masterObject.y + this.viewportY) < this.viewportLimitY)) {\n\t\t\t// \tdestY = this.viewportY + this.viewportCenterY;\n\t\t\t// } else if (((-this.viewportY + this.viewportH) - this.masterObject.y) < this.viewportLimitY) {\n\t\t\t// \tdestY = this.viewportY - this.viewportCenterY;\n\t\t\t// }\n\n\t\t\t// Scroll Type 2: direct\n\t\t\tif (this.viewportX && ((this.masterObject.x + this.viewportX) <= this.viewportLimitX)) {\n\t\t\t\tdestX = this.viewportX + this.viewportCenterX;\n\t\t\t} else if (((-this.viewportX + this.viewportW) - this.masterObject.x) <= this.viewportLimitX) {\n\t\t\t\tdestX = this.viewportX - this.viewportCenterX;\n\t\t\t}\n\n\t\t\tif (this.viewportY && ((this.masterObject.y + this.viewportY) <= this.viewportLimitY)) {\n\t\t\t\tdestY = this.viewportY + this.viewportCenterY;\n\t\t\t} else if (((-this.viewportY + this.viewportH) - this.masterObject.y) <= this.viewportLimitY) {\n\t\t\t\tdestY = this.viewportY - this.viewportCenterY;\n\t\t\t}\n\n\t\t\tif (destX !== null || destY !== null) {\n\t\t\t\tthis.moveTo(destX !== null ? destX : this.viewportX, destY !== null ? destY : this.viewportY);\n\t\t\t}\n\n\t\t\tif (destX !== null || destY !== null) {\n\t\t\t\tthis.moveTo(destX !== null ? destX : this.viewportX, destY !== null ? destY : this.viewportY);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t/**\n\t * \n\t * Checks for collisions\n\t * \n\t */\n\tcheckCollisions() {\n\t\tif (this.masterObject && this.masterObject.canCollide) {\n\t\t\tthis.checkMasterToEnemiesCollisions();\n\t\t}\n\n\t\tthis.checkMasterBulletsToEnemiesCollisions();\n\t}\n\n\n\t/**\n\t * \n\t * Check for map triggers and handle any found triggers, like enemies or bonus that can appear\n\t * when the player reaches certain positions\n\t * \n\t */\n\tcheckForTriggers() {\n\t\tlet box = this.masterObject.getHitBox(),\n\t\t\ttriggers = this.getTriggersForBox(this.masterObject.x + box.x, this.masterObject.y + box.y, this.masterObject.x + box.x2, this.masterObject.y + box.y2);\n\n\t\ttriggers.forEach((trigger) => {\n\t\t\ttrigger.triggered = !this.mapEvent.handleEvent(trigger);\n\t\t});\n\t}\n\n\t\n\t/**\n\t * Sets a new destination for the viewport: this method doesn't not set it immediately\n\t * but sets a new target instead: if not already moving, new move will happen at each\n\t * render inside the map.move() method\n\t * \n\t * @param {number} x The horizontal position to move the viewport at.\n\t * @param {number} y The vertical position to move the viewport at.\n\t * \n\t * @note moveTo will do nothing in case the map already has a destination set\n\t */\n\tmoveTo(x, y) {\n\t\t// TODO: snap x/y to screen edge\n\t\tif (!this.moving) {\n\t\t\tconsole.log('moveTo from', this.viewportX, 'to', x);\n\t\t\tif (this.masterObject) {\n\t\t\t\tthis.masterObject.savePosition();\n\t\t\t}\n\n\t\t\tthis.viewportTargetX = x > 0 ? 0 : x;\n\t\t\t// TODO: snap y to edge of the screen\n\t\t\tthis.viewportTargetY = y;\n\t\t\tthis.startMoveTime = new Date().getTime();\n\t\t\tthis.viewportSpeedX = x - this.viewportX | 0;\n\t\t\tthis.viewportSpeedY = y - this.viewportY | 0;\n\t\t\tthis.viewportStartX = this.viewportX;\n\t\t\tthis.viewportStartY = this.viewportY;\n\t\t\tthis.moving = true;\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Sets new tiles image source\n\t * \n\t * @param {Object} options\n\t * @param {String} options.src The new source.\n\t * \n\t * @private\n\t * \n\t */\n\tsetNewSrc(options) {\n\t\tthis.src = options.src;\n\t}\n\n\t\n\t/**\n\t * Returns current source image url used to render map tiles\n\t * \n\t * @returns {String} The current source image used to render the tiles.\n\t * \n\t * @private\n\t */\n\tgetSrc() {\n\t\treturn this.src;\n\t}\n\t\n\t\n\t/**\n\t * Checks if tile at position x,y is `TYPE.WALL` and returns true if it is a wall, false otherwise\n\t * \n\t * @param {number} x The x position of the tile to check.\n\t * @param {number} y The y position of the tile to check.\n\t * @returns {boolean} Returns true if the tile is a wall, false otherwise.\n\t * \n\t * @related {Tile}\n\t */\n\tfallTest(x, y) {\n\t\tlet pos = this.getTilePos(x, y);\n\n\t\t// return (!(this.tileTypes[pos.x + pos.y * this.numCols] & 1));\n\t\treturn this.tileTypes[pos.x + pos.y * this.numCols] === Tile.TYPE.WALL;\n\t}\n\n\t\n\t/**\n\t * \n\t * Checks collisions between master bullets and enemies: call hitTest method on\n\t * any frend bullet object with the enemies object as parameter\n\t * \n\t */\n\tcheckMasterBulletsToEnemiesCollisions() {\n\t\tlet i = 0,\n\t\t\tj = 0,\n\t\t\tbullet = null,\n\t\t\tenemy = null,\n\t\t\tmaxBullets = this.friendBullets.length,\n\t\t\tmaxEnemies = this.enemies.length;\n\n\t\tfor (i = 0; i < maxBullets; ++i) {\n\t\t\tfor (j = 0; j < maxEnemies; ++j) {\n\t\t\t\tif (this.enemies[j] && this.enemies[j].canCollideFriendBullet) {\n\t\t\t\t\tthis.friendBullets[i] && this.friendBullets[i].hitTest(this.enemies[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Checks collisions between master object and enemies, calling hitTest on any enemie\n\t * that collides with the master\n\t * \n\t * @returns {boolean} Returns true if the masterSprite was hit, false otherwise.\n\t * \n\t */\n\tcheckMasterToEnemiesCollisions() {\n\t\tlet i = 0,\n\t\t\tmax = this.enemies.length,\n\t\t\tfound = false;\n\n\t\t// TODO: player should have some invicibility for a few frames once it has\n\t\t// hit an enemy\n\t\twhile (i < max && !found) {\n\t\t\tfound = this.enemies[i].hitTest(this.masterObject);\n\t\t\ti++;\n\t\t}\n\n\t\treturn found;\n\t}\n\n\n\t/**\n\t * WIP: Check if user will reach a platform\n\t * \n\t * @param {any} sprite\n\t * @param {any} vx\n\t * @param {any} vy\n\t * @returns {boolean} false (not fully implemented yet)\n\t * \n\t * @private\n\t * \n\t */\n\tcheckForPlatform(object, vx, vy) {\n\t\tlet box = object.getHitBox(),\n\t\t\tx = box.x + sprite.x,\n\t\t\ty = box.y + sprite.y;\n\n\t\tthis.platforms.forEach((platform) => {\n\t\t\tlet platformBox = platform.getHitBox(),\n\t\t\t\tplatformX = platform.x + platformBox.x,\n\t\t\t\tplatformY = platform.y + platformBox.y;\n\t\t});\n\n\t\treturn false;\n\t}\n\n\t\n\t/**\n\t * getTriggers for map window: `(x, y, x2, y2)`\n\t * \n\t * @param {number} x The x coordonate of left top corner of the box to check for.\n\t * @param {numer} y The y coordonate of left top corner of the box to check for.\n\t * @param {numer} x2 The x coordonate of right bottom corner of the box to check for.\n\t * @param {number} y2 The y coordonate of right bottom corner of the box to check for.\n\t * \n\t * @returns {Array} a list of trigger objects that have not already been triggered\n\t * \n\t * @private\n\t */\n\tgetTriggersForBox(x, y, x2, y2) {\n\t\tlet pos1 = this.getTilePos(x, y),\n\t\t\tpos2 = this.getTilePos(x2, y),\n\t\t\tpos3 = this.getTilePos(x, y2),\n\t\t\t/* pos4 = this.getTilePos(x2, y2), */\n\t\t\tmax1 = pos2.x,\n\t\t\tmax2 = pos3.y,\n\t\t\ti, j,\n\t\t\ttriggers = [],\n\t\t\ttrigger = null;\n\n\t\tfor (i = pos1.x; i <= max1; i++) {\n\t\t\tfor (j = pos1.y; j <= max2; j++) {\n\t\t\t\ttrigger = this.triggers[j * this.numCols + i];\n\t\t\t\tif (trigger && !trigger.triggered) {\n\t\t\t\t\t// remove it so it cannot be triggered again: what if we want to run the map again ?\n\t\t\t\t\t// this.triggers[j * this.numCols + i] = null;\n\t\t\t\t\ttriggers.push(trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn triggers;\n\t}\n\n\t/**\n\t * Calculates and sets the object's next x position using its current x, vx and\n\t * avoids tileTypes tiles (ie: walls, moving platforms)\n\t * \n\t * @param {GfxObject} sprite The sprite to get next position of.\n\t * @param {number} tileTypes The tileType.\n\t * @returns {boolean} Returns true if the object hit the spcified tile, false otherwise\n\t * \n\t */\n\tsetNextX(sprite, tileTypes) {\n\t\t// TODO: if player moves too fast, or tiles are too small,\n\t\t// we may miss some tiles and do not detect colisions\n\t\t// TODO: 2. handle type of movingPlatform: platformType: 0 | 1\n\t\t// TODO: 3. Iterate through list of movingPlatforms of platformType [1] too\n\t\t// if closer than (sprite.x + sprite.vx [ +hitBox.x2 ]) && < maxX\n\t\t// then maxX = movingPlatform.size - 1\n\n\t\tconst left = (sprite.vx > 0) ? false : true;\n\n\t\tlet hitBox = sprite.getHitBox(),\n\t\t\tspriteYMax = sprite.y + hitBox.y2,\n\t\t\tstartX = left ? sprite.x + hitBox.x - 1 : sprite.x + hitBox.x2 + 1,\n\t\t\tstartY = sprite.y + hitBox.y,\n\t\t\ttilePos = this.getTilePos(startX, startY),\n\t\t\tfound = false,\n\t\t\tminX = left ? startX : 0;\n\t\t//\n\t\t// console.log('begin test');\n\t\t// left: minX >= sprite.vx => minX \n\t\twhile (!found && ( (left && (minX >= sprite.vx)) || (!left && (minX <= sprite.vx))) ) {\n\t\t\tfor (let i = tilePos.y * this.tileHeight; i < spriteYMax; i += this.tileHeight, tilePos.y++) {\n\t\t\t\t// DISABLE WALL COLLISIONS\n\t\t\t\t// TODO: add a parameter to toggle collisions at runtime\n\t\t\t\tif (this.tileTypes[tilePos.y * this.numCols + tilePos.x] === tileTypes) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tminX = left ? ((tilePos.x * this.tileWidth) - startX) : ((++tilePos.x * this.tileWidth) - startX);\n\t\t\t}\n\t\t\tstartX = left ? ((tilePos.x * this.tileWidth) - 1) : tilePos.x * this.tileWidth;\n\n\t\t\ttilePos = this.getTilePos(startX, startY);\n\t\t}\n\t\t// console.log('end test');\n\n\t\tif ((left && sprite.vx >= minX) || (!left && sprite.vx < minX)) {\n\t\t\tsprite.x += sprite.vx;\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconsole.log('**collision');\n\t\t\tsprite.x += minX;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * WIP: Calculates and sets the object's next y position using its current y, vy and\n\t * avoids tileTypes tiles (ie: walls, moving platforms)\n\t * \n\t * @param {any} sprite\n\t * @param {any} tileTypes\n\t * @returns true if the object hit a tile, false otherwise\n\t * \n\t */\n\tsetNextYTop(sprite, tileTypes) {\n\t\tlet hitBox = sprite.getHitBox,\n\t\t\tspriteXMax = sprite.x + hitBox.x2,\n\t\t\tstartX = sprite.x + hitBox.x,\n\t\t\tstartY = sprite.y + hitBox.x2 + 1,\n\t\t\ttilePos = this.getTilePos(startX, startY),\n\t\t\tfound = false,\n\t\t\tminY = 0;\n\n\t\t\t// while (!found && minY <= sprite.vy) {\n\t\t\t// \tfor (let i = tilePos.x * this.tileWidth; i < spriteXMax; i += this.tileWidth) {\n\t\t\t// \t\tif (this.tileTypes[tilePos.y * this.numCols + tilePos.x] === tileTypes) {\n\t\t\t// \t\t\tfound = true;\n\t\t\t// \t\t\tbreak;\n\t\t\t// \t\t}\n\t\t\t// \t}\t\t\t\t\n\t\t\t// }\n\n\t\t\tsprite.y += sprite.vy;\n\t}\n\n\t// setNextXRight(sprite, tileTypes) {\n\t// \tlet hitBox = sprite.getHitBox(),\n\t// \t\tspriteYMax = sprite.y + hitBox.y2,\n\t// \t\tstartX = sprite.x + hitBox.x2 + 1,\n\t// \t\tstartY = sprite.y + hitBox.y,\n\t// \t\ttilePos = this.getTilePos(startX, startY),\n\t// \t\tfound = false,\n\t// \t\tminX = 0;\n\n\t// \t\t//\n\t// \t\t// console.log('begin test');\n\t// \t\twhile (!found && minX <= sprite.vx) {\n\t// \t\t\t// check full sprite's height for a collision\n\t// \t\t\tfor (let i = tilePos.y * this.tileHeight; i < spriteYMax; i += this.tileHeight, tilePos.y++) {\n\t// \t\t\t\tif (this.tileTypes[tilePos.y * this.numCols + tilePos.x] === tileTypes) {\n\t// \t\t\t\t\tfound = true;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\n\t// \t\t\t// not found ? minX maybe next tile on the right then\n\t// \t\t\tif (!found) {\n\t// \t\t\t\tminX = (++tilePos.x * this.tileWidth) - startX;\n\t// \t\t\t}\n\t// \t\t\tstartX = tilePos.x * this.tileWidth;\n\n\t// \t\t\ttilePos = this.getTilePos(startX, startY);\n\t// \t\t}\n\t// \t\t// console.log('end test');\n\n\t// \t\tif (sprite.vx < minX) {\n\t// \t\t\tsprite.x += sprite.vx;\n\t// \t\t\treturn false;\n\t// \t\t} else {\n\t// \t\t\tsprite.x += minX;\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t}\n\n\t\n\t/**\n\t * Checks if an object is in front of a certain type of tileType,\n\t * optionnaly centering the object under the tile\n\t * \n\t * Used when checking if the player can climb a ladder for example\n\t * \n\t * spaceX/spaceY specify how to reduce the players hitbox\n\t * \n\t * @param {GfxObject} sprite The sprite to check.\n\t * @param {number} tileType The tileType to check for.\n\t * @param {number} [spaceX=0] The x padding that is accepted: if horizontal position is +/- that spaceX, check will succeed.\n\t * @param {number} [spaceY=0] The y padding that is accepted: if vertical position is +/- that spaceX, check will succeed.\n\t * @param {boolean} [center=false] Set to true if you want to sprite to be centered on the tile.\n\t * \n\t * @returns {boolean} True if the tile was found, false otherwise\n\t * \n\t */\n\tcheckForTileType(sprite, tileType, spaceX = 0, spaceY = 0, center = false) {\n\t\tconst currentHitBox = sprite.getHitBox(),\n\t\t\tpos = this.hitObjectTest(currentHitBox.x + sprite.x + spaceX, currentHitBox.y + sprite.y + spaceY, currentHitBox.x2 + sprite.x -spaceX, currentHitBox.y2 + sprite.y - spaceY, tileType);\n\n\t\tif (pos) {\n\t\t\t// TODO: center if center === true\n\t\t\tif (center) {\n\t\t\t\tsprite.centerXOverTile(pos);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\t\t\n\n\t\n\t/**\n\t * Tests if a rectangle collapses with certain types of tiles\n\t * Used when checking colligions between a sprite and walls for example\n\t * \n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} types\n\t * @returns {boolean} True if colision detected\n\t * \n\t */\n\thitObjectTest(x, y, x2, y2, types) {\n\t\tlet pos1 = this.getTilePos(x, y),\n\t\t\tpos2 = this.getTilePos(x2, y),\n\t\t\tpos3 = this.getTilePos(x, y2),\n\t\t\tmax1 = pos2.x,\n\t\t\tmax2 = pos3.y,\n\t\t\ti, j,\n\t\t\ttileType;\n\n\t\tfor (i = pos1.x; i <= max1; i++) {\n\t\t\tfor (j = pos1.y; j <= max2; j++) {\n\t\t\t\ttileType = this.tileTypes[j * this.numCols + i];\n\t\t\t\tif (tileType === types) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: i,\n\t\t\t\t\t\ty: j,\n\t\t\t\t\t\ttile: {\n\t\t\t\t\t\t\tx: i * this.tileWidth,\n\t\t\t\t\t\t\ty: j * this.tileHeight\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t\n\t/**\n\t * Draws tile at pixel position (x, y) onto the specified {Canvas} context\n\t * \n\t * @note If offset is true it means scroll is in progress and\n\t * we are drawing the first col: in this case we have to draw\n\t * a partial tile and we do not use tileWidth/tileHeight\n\t * but this.scrollTileOffsetX instead\n\t * \n\t * @param {number} tileNum The tile number to draw.\n\t * @param {CanvasContext} ctx The canvas rendering context to draw the tile into.\n\t * @param {number} x The horizontal position where to draw the tile.\n\t * @param {number} y The vertical position where to draw the tile.\n\t * @param {Boolean} useScrollOffset If set to true, the tile will be partially rendered\n\t * starting at scrollOffsetX. This happens if the tile is at the firstRow/firstCol of the viewport.\n\t * \n\t * @note Unless noted otherwise, positions are related to the whole map, and not to the viewport.\n\t */\n\tdrawTile(tileNum, ctx, x, y, useScrollOffset) {\n\t\tlet currentTile = this.tiles[tileNum];\n\n\t\tif (useScrollOffset) {\n\t\t\tctx.drawImage(this.srcBitmap,\n\t\t\t\t\t\t  currentTile.offsetX + this.scrollOffsetX,\n\t\t\t\t\t\t  currentTile.offsetY + this.scrollOffsetY,\n\t\t\t\t\t\t  this.scrollTileOffsetX,\n\t\t\t\t\t\t  this.scrollTileOffsetY,\n\t\t\t\t\t\t  x,\n\t\t\t\t\t\t  y,\n\t\t\t\t\t\t  this.scrollTileOffsetX,\n\t\t\t\t\t\t  this.scrollTileOffsetY);\n\t\t} else {\n\t\t\tctx.drawImage(this.srcBitmap,\n\t\t\t\t\t\t  currentTile.offsetX,\n\t\t\t\t\t\t  currentTile.offsetY,\n\t\t\t\t\t\t  this.tileWidth,\n\t\t\t\t\t\t  this.tileHeight,\n\t\t\t\t\t\t  x,\n\t\t\t\t\t\t  y,\n\t\t\t\t\t\t  this.tileWidth,\n\t\t\t\t\t\t  this.tileHeight);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Internal: calculates scrolling offsets for first cols in case a scrolling is in progress\n\t * \n\t * @private\n\t */\n\t_getScrollOffset() {\n\t\tlet viewportX = Math.abs(this.viewportX),\n\t\t\tviewportY = Math.abs(this.viewportY);\n\n\t\tthis.scrollOffsetX = viewportX < this.tileWidth ? viewportX : viewportX % this.tileWidth,\n\t\tthis.scrollOffsetY = viewportY < this.tileHeight ? viewportY : viewportY % this.tileHeight;\n\t\tthis.scrollTileOffsetX = this.tileWidth - this.scrollOffsetX;\n\t\tthis.scrollTileOffsetY = this.tileHeight - this.scrollOffsetY;\n\t}\n\n\t\n\t/**\n\t * Draws the map, showing the whole map and not only the visible window if showHidden true\n\t * \n\t * @param {CanvasContext} ctx The context of the canvas where to draw the map.\n\t * @param {boolean} showHidden The map only draws the viewport, set this to true to draw the whole map.\n\t * \n\t * @private\n\t */\n\tdraw(ctx, showHidden) {\n\t\tlet i, j, max, max2,\n\t\t\ttileNum = 0,\n\t\t\tx = 0,\n\t\t\ty = 0;\n\n\t\tif (!this.srcBitmap) {\n\t\t\t// console.log('[Map] no bitmap, need to get the source');\n\t\t\tthis.srcBitmap = RM.getResourceById(this.src);\n\t\t}\n\n\t\t// this.isDirty = true;\n\n\t\ti = j = max = max2 = 0;\n\t\t// 1. get first col/row of map\n\t\tif (this.isDirty || !this.lastCol) {\n\t\t\tthis._getBoundariesTiles(showHidden);\n\t\t}\n\n\t\tif (this.isDirty || !this.lastCol) {\n\t\t\tthis._getScrollOffset();\n\n\t\t\tfor (i = this.firstRow, max = this.lastRow, y = 0; i < max; i++) {\n\t\t\t\tfor (j = this.firstCol, max2 = this.lastCol, x = 0; j < max2; j++) {\n\t\t\t\t\ttileNum = this.map[i * this.numCols + j];\n\n\t\t\t\t\tif (tileNum < 255) { // no tile goes here\n\t\t\t\t\t\t// TODO: check that viewportY is not zero too ?\n\t\t\t\t\t\tthis.drawTile(tileNum, ctx, x, y, ((this.viewportY && i === this.firstRow) || (this.viewportX && j === this.firstCol)));\n\t\t\t\t\t}\n\t\t\t\t\tif (this.viewportX && j === this.firstCol) {\n\t\t\t\t\t\tx += this.scrollTileOffsetX;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += this.tileWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.viewPortY && i === this.firstRow) {\n\t\t\t\t\ty += this.scrollTileOffsetY;\n\t\t\t\t} else {\n\t\t\t\t\ty += this.tileHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* This should be done in another canvas */\n\t\t\tif (this.isDebug === true) {\n\t\t\t\tthis.showTileBehaviors(ctx, showHidden);\n\t\t\t}\n\n\t\t\tthis.addNewObjectsFromWindow();\n\n\t\t\tthis.isDirty = false;\n\t\t} else {\n\t\t\t// do not draw map otherwise\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Adds new Objects onto the map if this is the first time we display this window.\n\t * \n\t * Each map is divided into windows: each viewport window is the size of the current viewport\n\t * When drawing a window for the first time, objects found into this window are added to the map\n\t * It can be enemies, etc...\n\t * \n\t * @private\n\t */\n\taddNewObjectsFromWindow() {\n\t\tlet windowNum = ((Math.abs(this.viewportX) / this.viewportW) | 0) + ((Math.abs(this.viewportY) / this.viewportH) | 0),\n\t\t\twindow = this.windows[windowNum];\n\n\t\tif (window.displayed === false) {\n\t\t\twindow.displayed = true;\n\t\t\twindow.items.forEach((item, i) => {\n\t\t\t\tlet obj = RM.newResourceFromPool(item.type, item.spriteOptions);\n\t\t\t\tthis.addObject(obj);\n\t\t\t\t// add a reference to the sprite into mapEvent.items\n\t\t\t\t// this will be used to destroy sprite when puzzle is checked\n\t\t\t\t// for example\n\t\t\t\tif (item.itemId) {\n\t\t\t\t\tthis.mapEvent.addItem(item.itemId, obj);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Draw all objects that are onto the map\n\t * \n\t * @param {CanvasContext} ctx The context where to draw the objects.\n\t * \n\t * @private\n\t */\n\tdrawObjects(ctx) {\n\t\tlet i,\n\t\t\tmax = this.objects.length,\n\t\t\tobjects = this.objects;\n\n\t\t// TODO: only draw visible objects (viewport) + active ones\n\t\tfor (i = max - 1; i >= 0; i--) {\n\t\t\t// console.log('drawing', objects[i].id);\n\t\t\tobjects[i].draw(ctx, this.isDebug);\n\t\t}\n\t}\n\n\n\t/**\n\t * Returns the tile at (x, y) pixels\n\t * \n\t * @param {number} x The horizontal position in pixels.\n\t * @param {number} y The vertical position in pixels.\n\t * \n\t * @note Position is related to the whole map, not the viewport.\n\t * \n\t * @returns {Tile=undefined} The tile that is found at position x, y, undefined if tile `(x, y)` is out of bounds\n\t * \n\t */\n\tgetTileAt(x, y) {\n\t\tlet i,\n\t\t\tj,\n\t\t\ttileNum;\n\n\t\ti = x / this.tileWidth | 0;\n\t\tj = y / this.tileHeight | 0;\n\t\ttileNum = this.map[this.numCols * j + i];\n\n\t\treturn this.tiles[tileNum];\n\t}\n\t\n\t/**\n\t * Returns index of the tile at pos (x,y) in map array\n\t * \n\t * @param {number} x\n\t * @param {number} y\n\t * @returns {Object} Object with i, j tile index\n\t * \n\t */\n\tgetTilePos(x, y) {\n\t\tlet i,\n\t\t\tj;\n\n\t\ti = x / this.tileWidth | 0;\n\t\tj = y / this.tileHeight | 0;\n\n\t\treturn {\n\t\t\tx: i,\n\t\t\ty: j\n\t\t};\n\t}\n\n\t/**\n\t * \n\t * INTERNAL: Calculates the number of tile rows & cols, and number of rows/cols\n\t * per viewport window\n\t * \n\t * @private\n\t */\n\t_calcNumTiles() {\n\t\tthis.numCols = this.width / this.tileWidth | 0;\n\t\tthis.numRows = this.height / this.tileHeight | 0;\n\n\t\tthis.numViewportCols = this.viewportW / this.tileWidth | 0;\n\t\tthis.numViewportRows = this.viewportH / this.tileHeight | 0;\n\t}\n\n\t\n\t/**\n\t * Calculates first/last Row & Cool that is part of current display viewport\n\t * If showHidden is set to true we display the whole map so:\n\t * firstCol = firstRow = 0\n\t * lastCol/lastRow = lastCol/lastRow of the map\n\t * \n\t * @param {Boolean=false} showHidden Set to true to get boundaries for the whole map.\n\t * \n\t * @private\n\t */\n\t_getBoundariesTiles(showHidden) {\n\t\t// TODO: handle boundaries and reverse ?!!\n\t\t// offsetX is current x offset in pixel: we need to get the corresponding tile number\n\t\tif (showHidden) {\n\t\t\tthis.firstCol = 0;\n\t\t\tthis.firstRow = 0;\n\n\t\t\tthis.lastCol = this.width / this.tileWidth | 0;\n\t\t\t// console.log(this.viewportW, '/', this.tileWidth);\n\t\t\tthis.lastRow = this.height / this.tileHeight | 0;\n\t\t} else {\n\t\t\tthis.firstCol = Math.floor(-this.viewportX / this.tileWidth);\n\t\t\tthis.firstRow = Math.floor(-this.viewportY / this.tileHeight);\n\n\t\t\tthis.lastCol = this.firstCol + this.numViewportCols;\n\t\t\tthis.lastRow = this.firstRow + this.numViewportRows;\n\n\t\t\tif (this.viewportX % this.tileWidth) {\n\t\t\t\tthis.lastCol++;\n\t\t\t}\n\n\t\t\tif (this.viewportY % this.tileHeight) {\n\t\t\t\tthis.lastRow++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Send specified event to the NotificationManager\n\t * \n\t * @param {String} eventType The type of event to send.\n\t * @param {Object} data The data to send with the notification.\n\t * \n\t */\n\tnotify(eventType, data) {\n\t\tNM.notify(eventType, data);\n\t}\n\n\t\n\t/**\n\t * removeObject from the map\n\t * \n\t * @param {GfxObject} gfxObject The object to remove from the map.\n\t * \n\t * @note the object if automatically removed from collision lists\n\t * \n\t */\n\tremoveObject(gfxObject) {\n\t\tlet foundIndex = this.objects.indexOf(gfxObject);\n\n\t\tif (foundIndex > -1) {\n\t\t\tthis.objects.splice(foundIndex, 1);\n\t\t}\n\n\t\tfoundIndex = this.enemies.indexOf(gfxObject);\n\n\t\tif (foundIndex > -1) {\n\t\t\tthis.enemies.splice(foundIndex, 1);\n\t\t} else if ((foundIndex = this.friendBullets.indexOf(gfxObject)) > -1) {\n\t\t\tthis.friendBullets.splice(foundIndex, 1);\n\t\t}\n\t}\n\n\t\n    /**\n     * Schedule adding a new object to the map\n     * \n     * @param {String} spriteId The id of the new sprite to add.\n     * @param {Object} spriteOptions The options that will be passed to the object constructor.\n     * @param {number=0} delay The delay in milliseconds to wait before adding the object.\n     * @returns {GfxObject} the new object\n     * \n     */\n    scheduleSprite(spriteId, spriteOptions, delay) {\n       let sprite = RM.newResourceFromPool(spriteId, spriteOptions);\n\n        // No need to call setTimeout if delay is zero\n        if (delay) {\n            setTimeout( () => {\n                this.addObject(sprite);\n            }, delay);\n        } else {\n            this.addObject(sprite);\n        }\n\n        return sprite;\n\t}\n\n\t\n    /**\n     * Add a new wave of objects to the map\n\t * Used for example when the player triggers apparition of several enemies or bonuses\n     * \n     * @param {Object} options The options to pass to the wav object\n     * @returns\n     * \n\t * @related {Wave}\n     */\n    handleWave(options) {\n        // console.log('wave');\n        var waveSize = options.size,\n            wave = new Wave(options),\n            i = 0,\n            delay = 0;\n\n        options.spriteOptions.wave = wave;\n\n        for (i = 0; i < waveSize; i++) {\n            this.scheduleSprite(options.spriteId, options.spriteOptions, delay);\n            // setTimeout((function(options, map) { return function() {\n            //     // var sprite = new (RM.getResourceById(options.spriteId))(options.spriteOptions);\n            //     var sprite = RM.newResourceFromPool(options.spriteId, options.spriteOptions);\n            //     map.addSprite(sprite);\n            // };})(options, this.map), delay);\n            delay += options.delay || 0;\n        }\n\n        return false;\n\t}\n\n\t/**\n\t * DEBUG: draw outline of each tile with a different color, depending\n\t * on the type of tile\n\t * \n\t * @param {CanvasContext} ctx The canvas context to render outline on.\n\t * \n\t */\n\tshowTileBehaviors(ctx) {\n\t\tlet i, j, max, max2,\n\t\t\tx = 0,\n\t\t\ty = 0,\n\t\t\tstyles = [\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t'rgba(240,0,0,.6)',\n\t\t\t\t'rgba(0,0,240,.6)'\n\t\t\t],\n\t\t\tw,\n\t\t\th;\n\n\t\ti = j = max = max2 = 0;\n\n\t\tfor (i = this.firstRow, max = this.lastRow, y = 0; i < max; i++) {\n\t\t\tfor (j = this.firstCol, max2 = this.lastCol, x = 0; j < max2; j++) {\n\t\t\t\tw = (this.viewportX && j === this.firstCol) ? this.scrollTileOffsetX : this.tileWidth;\n\t\t\t\th = (this.viewPortY && i === this.firstRow) ? this.scrollTileOffsetY : this.tileHeight;\n\t\t\t\tif (this.tileTypes[i * this.numCols + j] > 1) {\n\t\t\t\t\t// if (this.tileTypes[i * this.numCols + j] > 1) {\n\t\t\t\t\t// \tdebugger;\n\t\t\t\t\t// }\n\t\t\t\t\tctx.fillStyle = styles[this.tileTypes[i * this.numCols + j]];\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(x, y);\n\t\t\t\t\tctx.lineTo(x + w, y);\n\t\t\t\t\tctx.lineTo(x + w, y + h);\n\t\t\t\t\tctx.lineTo(x, y + h);\n\t\t\t\t\tctx.lineTo(x, y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t\tif (this.viewportX && j === this.firstCol) {\n\t\t\t\t\tx += this.scrollTileOffsetX;\n\t\t\t\t} else {\n\t\t\t\t\tx += this.tileWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.viewPortY && i === this.firstRow) {\n\t\t\t\ty += this.scrollTileOffsetY;\n\t\t\t} else {\n\t\t\t\ty += this.tileHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t/**\n\t * \n\t * DEBUG: displays the list of each object and its type/id onto the console\n\t * \n\t * @private\n\t */\n\tgetObjectsList() {\n\t\tthis.objects.forEach((obj, i) => {\n\t\t\tconsole.log('[' + i + ']', obj.type, '(' + obj.id + ')');\n\t\t});\n\t}\n\t\n\t/**\n\t * WIP/DEBUG: converts current map into a string\n\t * \n\t * @returns {String} The json export of the map\n\t * \n\t * @private\n\t */\n\ttoString() {\n\t\t// exports the options needed to create current map\n\t\t// especially usefull when working on a new map with the MapEditor\n\t\t//\n\t\tlet i = 0,\n\t\t\tmax = this.tiles.length,\n\t\t\ttile = null,\n\t\t\tobj = {\n\t\t\t\tsrc: this.src,\n\t\t\t\tviewportX: 0,\n\t\t\t\tviewportY: 0,\n\t\t\t\tviewportW: this.viewportW,\n\t\t\t\tviewportH: this.viewportH,\n\t\t\t\twidth: this.width,\n\t\t\t\theight: this.height,\n\t\t\t\ttileWidth: this.tileWidth,\n\t\t\t\ttileHeight: this.tileHeight,\n\t\t\t\tmap: this.map,\n\t\t\t\tbjects: this.objects,\n\t\t\t\ttiles: []\n\t\t\t};\n\n\t\tfor (i = 0; i < max; i++) {\n\t\t\ttile = this.tiles[i];\n\t\t\tobj.tiles.push('new Tile({' +\n\t\t\t\t'offsetX: tile.offsetX,' +\n\t\t\t\t'offsetY: tile.offsetY,' +\n\t\t\t\t'width: tile.width,' +\n\t\t\t\t'height: tile.height,' +\n\t\t\t\t'inertia: tile.inertia,' +\n\t\t\t\t'upCollide: tile.upCollide,' +\n\t\t\t\t'downCollide: tile.downCollide' +\n\t\t\t\t'}),');\n\t\t}\n\n\t\treturn JSON.stringify(obj);\n\t}\n\n\t\n\t/**\n\t * DEPRECATED: Creates tiles from an array of tiles description\n\t * \n\t * @param {any} tilesArray\n\t * @returns array of tile objects\n\t * \n\t * @private\n\t */\n\t_createTiles(tilesArray) {\n\t\t// TODO: replace with map()\n\t\tlet tiles = [];\n\n\t\ttilesArray.forEach((tileDesc) => {\n\t\t\ttiles.push(new Tile(tileDesc));\n\t\t});\n\n\t\treturn tiles;\n\t}\n\n\n\t/**\n\t * WIP & NOT TESTED: some code to allow resizing a map, was to be used in map editor\n\t * \n\t * @param {string} direction Where to extend the map, can be 'bottomLeft', 'bottomRight', 'topLeft', 'topRight'\n\t * @param {Object} options\n\t * \n\t * @private\n\t */\n\tresize(direction, options) {\n\t\t/*\n\t\t\tonly increases size for now (decrease means we may loose some objects,...)\n\t\t\tdirection:\n\t\t\t'topleft' == top -> bottom, left -> right (option = {newWidth, newHeight})\n\t\t\t'topright' == top -> bottom, right -> left (option = {newWidth, newHeight})\n\t\t\t'bottomleft' == bottom -> top, left -> right (option = {newWidth, newHeight})\n\t\t\t'bottomright' == bottom -> top, right -> left (option = {newWidth, newHeight})\n\t\t\t'center' == center -> each side (option = {newSize})\n\t\t*/\t\t\n\t\tlet buffer = null,\n\t\t\ttriggers = {},\n\t\t\titemBlocks = {},\n\t\t\tmap = null,\n\t\t\ttileTypes = null,\n\t\t\titem = null,\n\t\t\titems = null;\n\n\t\t// TODO: should we allow changing viewpPort size as well ?\n\t\t/*\t\t\t\tthis.width = width;\n\t\t\t\t\t\tthis.height = height;\n\t\t\t\t\t\tthis.viewportW = vpWidth;\n\t\t\t\t\t\tthis.viewportH = vpHeight;\n\t\t\t\t\t\tthis.viewportX = 0;\n\t\t\t\t\t\tthis.viewportY = 0;*/\n\n\t\tif (direction === 'bottomleft') {\n\t\t\tlet diffWidth = options.newWidth - this.width,\n\t\t\t\tdiffHeight = options.newHeight - this.height,\n\t\t\t\tnumCols = options.newWidth / this.tileWidth | 0,\n\t\t\t\tnumRows = options.newHeight / this.tileHeight | 0,\n\t\t\t\tdiffCols = numCols - this.numCols,\n\t\t\t\tdiffRows = numRows - this.numRows,\n\t\t\t\toldBlockX = this.width / this.viewportW | 0,\n\t\t\t\toldBlockY = this.height / this.viewportH | 0,\n\t\t\t\tnewBlockX = options.newWidth / this.viewportW | 0,\n\t\t\t\tnewBlockY = options.newHeight / this.viewportH | 0,\n\t\t\t\tnewBlocksX = newBlockX - oldBlockX,\n\t\t\t\tnewBlocksY = newBlockY - oldBlockY;\n\n\t\t\t// create new buffer for map tiles + behaviors\n\t\t\tbuffer = new ArrayBuffer(numCols * numRows * 2),\n\t\t\t\tmap = new Uint8Array(buffer, 0, numRows * numCols),\n\t\t\t\ttileTypes = new Uint8Array(buffer, numRows * numCols, numRows * numCols);\n\n\t\t\t// new buffer is automatically filled with zeros\n\t\t\t// so we only need to copy existing tiles/behaviors into the new\n\t\t\t// buffer at the correct position\n\t\t\tfor (let y = diffRows; y < numRows; y++) {\n\t\t\t\tfor (let x = 0; x < this.numCols; x++) {\n\t\t\t\t\tmap[(y * numCols) + x] = this.map[(y * numCols) + x];\n\t\t\t\t\ttileTypes[(y * numCols) + x] = this.tileTypes[(y * numCols) + x];\n\n\t\t\t\t\tif (this.triggers[(y * numCols) + x]) {\n\t\t\t\t\t\titem = Object.assign({}, true, this.triggers[(y * numCols) + x]);\n\t\t\t\t\t\tif (item.spriteOptions) {\n\t\t\t\t\t\t\titem.spriteOptions.y += diffHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttriggers[(y * numCols) + x] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setBuffer(buffer);\n\t\t\tthis.width = options.newWidth;\n\t\t\tthis.height = options.newHeight;\n\n\t\t\tthis.triggers = triggers;\n\n\t\t\tthis._calcNumTiles();\n\n\t\t\t// this was the easiest part, now we need to update triggers and mapblocks\n\t\t\t// if needed, we simply create new blocks, but do not modify blocks (we would\n\t\t\t// need to move each item depending on position, this is too much work)\n\t\t\t// simply add existing blocks, new ones are empty so should not be added\n\t\t\tfor (let y = newBlocksY; y < newBlockY; ++y) {\n\t\t\t\tfor (let x = 0; x < oldBlockX; ++x) {\n\t\t\t\t\tif (this.windows[y * oldBlockX + x]) {\n\t\t\t\t\t\titems = this.windows[y * oldBlockX + x].items;\n\n\t\t\t\t\t\tfor (let num = 0; num < items.length; ++num) {\n\t\t\t\t\t\t\titem = Object.assign({}, items[num]);\n\t\t\t\t\t\t\t// we consider x and y are always set\n\t\t\t\t\t\t\tif (item.spriteOptions) {\n\t\t\t\t\t\t\t\titem.spriteOptions.y += diffHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO: since we're doing this.windows = mapItemBlocks we\n\t\t\t\t\t\t// should copy and not only get references of each element\n\t\t\t\t\t\titemBlocks[y * oldBlockX + x] = {\n\t\t\t\t\t\t\tdisplayed: false,\n\t\t\t\t\t\t\titems: items.slice(0)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.windows = itemBlocks;\n\n\t\t\t// that's all folks !\n\t\t\t// TODO: test me!\n\t\t} else {\n\t\t\tthrow 'resize not support for direction' + direction;\n\t\t}\n\t}\n};\n\nexport default Map;\n\n\n// WEBPACK FOOTER //\n// ./js/Map/Map.js","/*jshint devel: true*/\r\n/**\r\n * MapEvent handles events that are triggered on the map.\r\n * Such events can be: checkpoint was reached, new wave needs to\r\n * be generated, etc...\r\n * \r\n * For that, the MapEvent class stores a list of items, events, switches\r\n * that are on the map.\r\n * \r\n * This is a default MapEvent class: games should extend MapEvent\r\n * to handle whatever events they need.\r\n * \r\n * @param {Map} map The [`Map`](#Map) to use\r\n */\r\nexport default class MapEvent{\r\n    constructor(map) {\r\n        console.log('[MapEvent] init with map');\r\n        this.map = map || null;\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets the MapEvent switches, events and items\r\n     */\r\n    reset() {\r\n        this.switches = {};\r\n        this.events = [];\r\n        this.items = {};\r\n    }\r\n\r\n    /**\r\n     * Adds a new [`GfxObject`]{#item} onto the map\r\n     * \r\n     * @param {string} id of the item to add\r\n     * @param {GfxObject} item to add\r\n     */\r\n    addItem(id, item) {\r\n        this.items[id] = item;\r\n    }\r\n\r\n    /**\r\n     * Returns an item\r\n     * \r\n     * @param {string} id of the item to retrieve\r\n     * \r\n     * @returns {Object|undefined} The item or undefined if it wasn't handled by the map\r\n     */\r\n    getItem(id) {\r\n        return this.items[id];\r\n    }\r\n\r\n    // TODO: ability to trigger an event once a switch has been modified\r\n    setSwitch(id, bool) {\r\n        this.switches[id] = bool;\r\n    }\r\n\r\n    toggleSwitch(id) {\r\n        this.setSwitch(id, typeof this.switches[id] !== 'undefined' ? !this.switches[id] : true);\r\n    }\r\n\r\n    getSwitch(id) {\r\n        return this.switches[id] || false;\r\n    }\r\n\r\n    checkConditions(trigger) {\r\n        var conditions = trigger.conditions,\r\n            cond = null,\r\n            i,\r\n            success = true,\r\n            max;\r\n\r\n        if (!conditions) {\r\n            return true;\r\n        } else {\r\n            // test that all conditions are valid\r\n            for (i = 0, max = conditions.length; i < max; i++) {\r\n                cond = conditions[i];\r\n                switch (cond.type) {\r\n                    case 'time':\r\n                        // compare time\r\n                        break;\r\n\r\n                    case 'switch':\r\n                        // get switch & status and compare\r\n                        // console.log('getting switch', cond.id, '=>', cond.status);\r\n                        success = this.getSwitch(cond.id) === cond.status;\r\n                        break;\r\n                }\r\n\r\n                if (!success) {\r\n                    break;\r\n                }\r\n            }\r\n            return success;\r\n        }\r\n    }\r\n\r\n    handleAction(options) {\r\n        var sprite;\r\n\r\n        // handle action\r\n        switch (options.type) {\r\n            case 'toggleSwitch':\r\n                sprite = options.sprite;\r\n                // toggle Sprite image\r\n                sprite.toggleSwitch();\r\n                // and set internal state for this sprite id\r\n                this.toggleSwitch(sprite.id);\r\n                break;\r\n\r\n            default:\r\n                // super.handleAction(options);\r\n                console.log('[MapEvent] non-handled action type', options.type);\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleEvent(options) {\r\n        var type = options.type,\r\n            item = null;\r\n\r\n        if (this.checkConditions(options)) {\r\n            switch (type) {\r\n                case 'cp':\r\n                    this.map.setStartXYFromMaster();\r\n                    break;\r\n\r\n                case 'message':\r\n                    this.map.notify('game:message', {\r\n                        message: options.message\r\n                    });\r\n                    break;\r\n\r\n                case 'wave':\r\n                    return this.map.handleWave(Object.assign({}, options));\r\n                    break;\r\n\r\n                case 'explosion':\r\n                    // generate explosion\r\n                    this.map.scheduleSprite(options.spriteId, options.spriteOptions, 0);\r\n\r\n                    item = this.getItem(options.targetId);\r\n\r\n                    item.destroy();\r\n                    break;\r\n\r\n                default:\r\n                    // return super.handleEvent(options);\r\n                    console.log('non-handled Event', options.type);\r\n                    break;\r\n            }\r\n        } else {\r\n            // we need to recheck a non triggered event\r\n            return true;\r\n        }\r\n    }\r\n\r\n    triggerEvent(id) {\r\n        this.events.push(id);\r\n    }\r\n\r\n    isEventTriggered(id) {\r\n        return this.events.indexOf(id) > -1;\r\n    }\r\n\r\n    // handleEvent(options) {\r\n    //     console.warn('[MapEvent] Unhandled event', options.type);\r\n    //     return false;\r\n    // }\r\n\r\n    // handleAction(options) {\r\n\r\n    // }\r\n};\n\n\n// WEBPACK FOOTER //\n// ./js/Map/MapEvent.js","import GfxObject from 'Object/Object';\nimport FX from 'FX/FX';\n\n\t/*jshint devel: true, bitwise: false*/\n\t/*globals Class*/\n\t/**\n\t * The BitmapText class allows to use a spritesheet as a font to draw text onto the screen\n\t * \n\t * @param {String} type The type of the sprite.\n\t * @param {Object} options The options describing the BitmapText.\n\t * @param {String} options.imageSrc The path to the spritesheet file.\n\t * @param {Number} [options.offsetX=0] The optional horizontal offset at which to start getting bitmap characters inside the spritesheet.\n\t * @param {Number} [options.bmStartY=0] The optinal vertical offset at which to start getting bitmap characters.\n\t * @param {Number} charWidth the width of a character in pixels.\n\t * @param {Number} charHeight The height of a character in pixels.\n\t * \n\t * @note the charset is limited to a subset of ascii right now: a-z 0-9\n\t * @example\n\t * \n\t *\tlet myFont = new BitmapText('myFont', {\n\t *\t\toffsetX: 34,\n\t *\t\tbmStartY: 36,\n\t *\t\tcharWidth: 16,\n\t *\t\tcharHeight: 18,\n\t *\t\timageSrc: 'font'\n\t *\t});\n\t */\n\tclass BitmapText extends GfxObject{\n        constructor(type, options) {\n            super(type, options);\n\n            this.imageSrc = options.imageSrc;\n\n\t\t\t// TODO: maybe we want to have fullsize ?\n\t\t\tthis.w = options.w || 320;\n\t\t\tthis.h = options.h || 18;\n\n            this.pixelHeight = 0;\n\n\t\t\tthis.maxLines = Math.floor(this.h / (this.charHeight + this.lineSpacing))\n\n\t\t\tthis.easing = FX.getEasing(options.easing || 'linear');\n\n\t\t\tthis.imageSrc = options.imageSrc || 'image not set';\n\n\t\t\t// TODO: buffer should be created here and not when object is added to the scene\n            this.buffer = null;\n\n\t\t\tthis.image = null;\n\n\t\t\tthis.scrolling = false;\n\n\t\t\tthis.text = options.text || 'BitmapText';\n\n            /*\t\t\tthis.charCodes = this.getCharCodes(this.text);*/\n\n\t\t\tthis.scrollOffsetX = options.scrollOffsetX || 0;\n\t\t\tthis.scrollOffsetY = options.scrollOffsetY || 0;\n\n\t\t\tthis.textArray = [];\n\n            this.setFontParams(options);\n        }\n        \n\t\t/**\n\t\t * Generates a new buffer that can hold current text\n\t\t * \n\t\t * @param {Display} display the display to get the buffer from\n\t\t */\n        createBuffer(display) {\n\t\t\t// generate a buffer with enough height to hold every lines of text\n\t\t\tlet width = this.w,\n\t\t\t\theight = this.textArray.length * (this.charHeight + this.lineSpacing);\n\n            this.buffer = display.getBuffer(width, height);\n        }\n        \n\t\t/**\n\t\t * Clears the buffer\n\t\t */\n        clearBuffer() {\n            this.currentScene.display.clearScreen(this.buffer);\n        }\n    \n\t\t/**\n\t\t * Sets bitmapText properties using options\n\t\t * \n\t\t * @param {Object} options\n\t\t */\n        setFontParams(options) {\n            this.lineSpacing = options.lineSpacing || 2;\n            this.letterSpacing = options.letterSpacing || 2;\n\n            this.charWidth = options.charWidth || 16;               // 16\n            this.charHeight = options.charHeight || 18;     // 18\n            this.maxCharPerLine = Math.floor(this.w / (this.charWidth + this.letterSpacing));\n            this.maxPixels = this.maxCharPerLine * ((this.charWidth + this.letterSpacing));\n\n            this.offsetX = options.offsetX || 0;     // 34\n            this.offsetY = options.offsetY || 0;     // 0\n            this.bmStartX = options.bmStartX || 0;  // 0\n            this.bmStartY = options.bmStartY || 0;  // 36\n        }\n        \n\t\t/**\n\t\t * Resets the bitmapFont to its default options\n\t\t */\n\t\treset() {\n\t\t\tsuper.reset();\n\t\t\tthis.setTextPosition();\n\t\t}\n/*\t\tgetCharCodes: function(str) {\n\t\t\tvar charCodes = [];\n\n\t\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\t\tcharCodes.push(str.charCodeAt(i));\n\t\t\t}\n\t\t},*/\n\t\t/**\n\t\t * Returns the lenght of a text line, in characters\n\t\t * \n\t\t * @param {String} str The string to mesure.\n\t\t * @param {String} eof The character to use as end of line.\n\t\t * \n\t\t * @returns {Number} The length of the string\n\t\t */\n\t\tgetNextLineLength(str, eof) {\n\t\t\tlet length = 0;\n\n\n\t\t\twhile(length < str.length && str[length] !== eof) {\n\t\t\t\tlength++;\n\t\t\t}\n            \n\t\t\treturn length;\n\t\t}\n\n\t\t/**\n\t\t * Calculates the position and size of each pixel lines to be rendered onto the screen\n\t\t */\n\t\tgetLines() {\n\t\t\tlet str = this.text,\n\t\t\t\tline = '',\n\t\t\t\tend = false,\n\t\t\t\ti = 0,\n\t\t\t\tj = 0,\n\t\t\t\tsize = 0;\n\n\t\t\t// reset textarray\n\t\t\tthis.textArray.length = 0;\n\n\t\t\twhile (!end) {\n\t\t\t\tstr = str.replace(/^\\n/, '');\n\t\t\t\ti = this.getNextLineLength(str, '\\n');\n\n\t\t\t\tif (i) {\n\t\t\t\t\tline = str.substr(0, i);\n\t\t\t\t\tif (line.length <= this.maxCharPerLine) {\n\t\t\t\t\t\t// start with line length\n\t\t\t\t\t\tstr = str.substr(i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we need to cut text\n\t\t\t\t\t\tline = str.substr(0, this.maxCharPerLine);\n\t\t\t\t\t\t// start with line length\n\t\t\t\t\t\tstr = str.substr(this.maxCharPerLine);\n\t\t\t\t\t}\n\n\t\t\t\t\t// add new line\n\t\t\t\t\tthis.textArray.push({\n\t\t\t\t\t\ttext: line,\n\t\t\t\t\t\tx: this.align === 'center' ? Math.floor((this.maxPixels - (line.length * (this.charWidth + this.letterSpacing))) / 2): 0,\n\t\t\t\t\t\ty: j\n\t\t\t\t\t});\n\n\t\t\t\t\tj += this.charHeight + this.lineSpacing;\n\t\t\t\t} else {\n\t\t\t\t\tend = true;\n\t\t\t\t}\n\t\t\t}\n\n            this.pixelHeight = this.textArray.length * (this.charHeight + this.lineSpacing);\n\t\t}\n        \n\t\t/**\n\t\t * Scrolls text from the bottom to the top, firing an optional callback at the end\n\t\t * \n\t\t * @param {Number} The duration of the scrolling in milliseconds.\n\t\t * @param {Function=undefined} An optional callback to fire when the scrolling is over.\n\t\t */\n        scrollFromBottom(duration, callback) {\n            // set scrollPos to offscreen\n            this.scrollOffsetY = this.h;\n\n            this.scrollText({\n                callback: callback,\n                duration: duration,\n                targetOffsetX: 0,\n                targetOffsetY: this.h - this.pixelHeight\n            });\n        }\n\n\t\t/**\n\t\t * Scrolls text from the top, firing an optional callback at the end\n\t\t * \n\t\t * @param {Number} The duration of the scrolling in milliseconds.\n\t\t * @param {Function=undefined} An optional callback to fire when the scrolling is over.\n\t\t */\n        scrollFromTop(duration, callback) {\n            // set scrollPos to offscreen\n            this.scrollOffsetY = -this.pixelHeight;\n\n            this.scrollText({\n                callback: callback,\n                duration: duration,\n                targetOffsetX: 0,\n                targetOffsetY: 0\n            });\n        }\n        \n\t\t/**\n\t\t * Scrolls the current text block\n\t\t * \n\t\t * @param {Object} options\n\t\t * @param {Number} options.targetOffsetX The horizontal destination of the scrolling.\n\t\t * @param {Number} options.targetOffsetY The vertical destination of the scrolling.\n\t\t * @param {Number} options.duration The duration of the scrolling, in milliseconds.\n\t\t * @param {Function} [options.callback=undefined] An optional callback function to call when the scrolling is done.\n\t\t * \n\t\t * @note if a scrolling is already in progress, nothing happens\n\t\t * \n\t\t * @private\n\t\t */\n\t\tscrollText(options) {\n\t\t\tif (!this.scrolling) {\n                console.log('starting scrolling');\n\t\t\t\tthis.scrolling = true;\n\n\t\t\t\tthis.callback = options.callback && options.callback.bind(this) || null;\n\t\t\t\tthis.duration = options.duration || 10000;\n\n\t\t\t\tthis.targetOffsetX = options.targetOffsetX;\n\t\t\t\tthis.targetOffsetY = options.targetOffsetY;\n\n\t\t\t\tthis.startX = this.scrollOffsetX;\n\t\t\t\tthis.startY = this.scrollOffsetY;\n\n\t\t\t\tthis.speedX = this.targetOffsetX - this.startX | 0;\n\t\t\t\tthis.speedY = this.targetOffsetY - this.startY | 0;\n\n\t\t\t\tthis.startMoveTime = new Date().getTime();\n\t\t\t}\n\t\t}\n        \n\t\t/**\n\t\t * Does nothing\n\t\t * \n\t\t * @private\n\t\t */\n\t\tsetTextPosition() {\n\t\t\t// set back text position (resets scrolling)\n\t\t}\n        \n\t\t/**\n\t\t * Move() is called at each render loop and calculates the next position during a scrolling\n\t\t */\n\t\tmove() {\n\t\t\tlet currentTime = new Date().getTime(),\n\t\t\t\tellapsedTime = currentTime - this.startMoveTime,\n\t\t\t\tt = ellapsedTime / this.duration,\n\t\t\t\tmoveProgress;\n\n\t\t\tif (this.scrolling === true) {\n\t\t\t\tif (ellapsedTime >= this.duration) {\n\t\t\t\t\tthis.scrolling = false;\n\t\t\t\t\tthis.scrollOffsetX = this.targetOffsetX;\n\t\t\t\t\tthis.scrollOffsetY = this.targetOffsetY;\n                    if (this.callback) {\n                        this.callback();\n                    }\n\t\t\t\t} else {\n\t\t\t\t\tmoveProgress = this.easing(t, ellapsedTime, 0, 1, this.duration);\n\n\t\t\t\t\tthis.scrollOffsetX = this.startX + moveProgress * this.speedX | 0;\n\t\t\t\t\tthis.scrollOffsetY = this.startY + moveProgress * this.speedY | 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\t/**\n\t\t * Returns the character horizontal offset in pixels inside the spritesheet\n\t\t * \n\t\t * @param {String} char The character to get the position inside the spritesheet\n\t\t * \n\t\t * @returns {Number} The horizontal offset in pixels of the character\n\t\t */\n\t\tgetCharOffset(char) {\n\t\t\t// The magic happens here!\n\t\t\tlet code = char.toUpperCase().charCodeAt(0) - 65;\n\n\t\t\treturn code * this.offsetX;\n\t\t}\n        \n\t\t/**\n\t\t * Draws the specified line onto the screen\n\t\t * \n\t\t * @param {Object} options\n\t\t * @param {Number} options.x The horizontal position of the line to draw\n\t\t * @param {Number} options.x The vertical position of the line to draw\n\t\t * @param {String} options.text The text to draw\n\t\t * \n\t\t * @example\n\t\t * \n\t\t * bitmapText.drawLine({\n\t\t * \tx: 0,\n\t\t *  y: 0,\n\t\t *  text: 'hi there'\n\t\t * })\n\t\t */\n\t\tdrawLine(options) {\n\t\t\tlet x = options.x,\n\t\t\t\ty = options.y,\n\t\t\t\ti = 0,\n                offset = 0,\n\t\t\t\tmax = options.text.length;\n\n\t\t\t// draw each character\n\t\t\tfor (i = 0; i < max; ++i) {\n                if (options.text[i].charCodeAt(0) !== 32) {\n                    offset = this.getCharOffset(options.text[i]);\n\t\t\t\t    this.buffer.drawImage(this.image, offset, this.bmStartY, this.charWidth, this.charHeight, x, y, this.charWidth, this.charHeight);\n                }\n                x += this.letterSpacing + this.charWidth;\n\t\t\t}\n\t\t}\n        \n        /**\n\t\t * Pre-renders text from this.textArray into the internal buffer\n\t\t * \n\t\t */\n        renderText() {\n            let i = 0,\n                max = 0,\n                line;\n\n            max = this.textArray.length;\n\n            for (i = 0; i < max; ++i) {\n                line = this.textArray[i];\n                this.drawLine(line);\n            }\n        }\n        \n\t\t/**\n\t\t * Changes the text of the sprite, calculates every line size, and renders it into\n\t\t * the internal buffer\n\t\t * \n\t\t * @param {String} text The new text to use\n\t\t */\n\t\tsetText(text) {\n        \tthis.text = text;\n\n\t\t\tthis.getLines();\n\n\t\t\t// generate wide-enough internal buffer to hold every lines of text\n\t\t\tif (!this.buffer) {\n\t\t\t\tthis.createBuffer(this.currentScene.display);\n\t\t\t} else {\n                this.clearBuffer();\n            }\n\n\t\t\tthis.renderText(this.text);\n\t\t}\n        \n\t\t/**\n\t\t * Changes the image to use as spritesheet\n\t\t * \n\t\t * @param {Image} image The new {image} to use as source.\n\t\t */\n\t\tsetImage(image) {\n\t\t\tthis.image = image;\n\t\t}\n        \n\t\t/**\n\t\t * Sets the scene of the bitmap font\n\t\t * \n\t\t * @param {Scene} scene The scene to use.\n\t\t */\n\t\tsetScene(scene) {\n\t\t\tsuper.setScene(scene);\n\n\t\t\tthis.setText(this.text);\n\t\t}\n        \n\t\t/**\n\t\t * Draws pre-rendered into destination buffer\n\t\t * \n\t\t * @param {CanvasContext} destCtx The new cancas context where to draw the bitmap font.\n\t\t * @param {Boolean} debug Wether to draw debug stuff.\n\t\t * \n\t\t * @note: once added onto the scene, this method is automatically called at each render loop.\n\t\t * \n\t\t * @related {Scene}\n\t\t * \n\t\t * @private\n\t\t */\n        draw(destCtx, debug) {\n            var destY,\n                copyHeight,\n                copyStartY;\n\n\t\t\tif (!this.visible) {\n\t\t\t\treturn;\n\t\t\t}\n\n            if (this.scrollOffsetY >= 0) {\n                destY = this.scrollOffsetY;\n                copyHeight = this.h - destY;\n                copyStartY = 0;\n            } else {\n                destY = 0;\n                copyHeight = this.h;    // auto clipped ?\n                copyStartY = Math.abs(this.scrollOffsetY);\n            }\n\t\t\t// if this.scrolling, need to first offset text into this.buffer\n\n            if (this.isFxQueueEmpty()) {\n                // draw\n\t\t\t\t// throw 'TODO: drawing of bitmapText';\n\t\t\t\t// TODO: should use scrollPos to update destination and simulate horizontal/vertical text scrolling\n\t\t\t\tdestCtx.drawImage(this.buffer.canvas, 0, copyStartY, this.w, copyHeight, this.x + this.scrollOffsetX, this.y + destY, this.w, copyHeight);\n\t\t\t\t// destCtx.drawImage(this.image, Math.floor(this.x), Math.floor(this.y), Math.floorthis.(w), Math.floor(this.h), Math.floor(drawX + mapOffsetX), Math.floor(drawY + mapOffsetY), Math.floor(scaledW), Math.floor(scaledH));\n            } else {\n                this.executeFx(destCtx);\n\t\t\t\tthrow 'TODO: drawing of bitmapText';\n            }\n\n            if (debug) {\n                this.showObjectBox(destCtx);\n            }\n        }\n    };\n\n    export default BitmapText;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/BitmapText.js","import RM from 'Resource/ResourceManager';\n\n\texport default class Wave {\n\t\tconstructor(options) {\n\t\t\tthis.counter = options.size;\n\t\t\tthis.type = options.afterDestroy;\n\t\t\tthis.data = options.afterDestroyData;\n\t\t}\n        \n\t\tremove(element) {\n\t\t\tthis.counter--;\n\n\t\t\tif (!this.counter) {\n\t\t\t\tthis.destroy(element);\n\t\t\t}\n\t\t}\n        \n\t\tdestroy(element) {\n\t\t\tswitch(this.type) {\n\t\t\t\tcase 'reward':\n\t\t\t\t\tif (this.data) {\n\t\t\t\t\t\tlet reward = new (RM.getResourceById('SmallItem'))({\n\t\t\t\t\t\t\tx: element.x + 24,\t// bad: hardcoded !!\n\t\t\t\t\t\t\ty: element.y - 20,\n              \t\t\t\tvy: -2,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\titemType: this.data\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\telement.currentMap.addObject(reward);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow('reward not implemented', this.type);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Wave.js","export { default as Game } from 'Core/Game';\r\n\r\nexport { default as Pool } from 'Core/Pool';\r\n\r\nexport { default as Scene } from 'Scene/Scene';\r\n\r\nexport { default as ResourceManager } from 'Resource/ResourceManager';\r\nexport { default as Object } from 'Object/Object';\r\n\r\nexport { default as Sprite } from 'Object/Sprite';\r\nexport { default as Text } from 'Object/Text';\r\nexport { default as Wave } from 'Object/Wave';\r\nexport { default as Menu } from 'Object/Menu';\r\nexport { default as Hud } from 'Object/Hud';\r\nexport { default as BitmapText } from 'Object/BitmapText';\r\nexport { default as Circle } from 'Object/Circle';\r\n\r\nexport { default as NotificationManager } from 'Notification/NotificationManager';\r\n\r\nexport { default as Map } from 'Map/Map';\r\nexport { default as MapEvent } from 'Map/MapEvent';\r\n\r\nexport { default as FX } from 'FX/FX';\r\nexport { default as Easing } from 'FX/Easing/Easing';\r\n\r\nexport { default as InputManager } from 'Input/InputManager';\r\nexport { default as DisplayManager } from 'Display/DisplayManager';\r\n\r\nexport { default as Display } from 'Display/Display';\r\n\r\nexport { default as AudioManager } from 'Audio/AudioManager';\r\nexport { default as Binary } from 'Binary/Binary';\r\n\r\nexport { default as Dom } from 'Core/Dom';\n\n\n// WEBPACK FOOTER //\n// ./js/athena-module.js","/*jshint devel: true, bitwise: false*/\r\nimport ResourceManager from 'Resource/ResourceManager';\r\nimport Binary from 'Binary/Binary';\r\nimport DisplayManager from 'Display/DisplayManager';\r\nimport AudioManager from 'Audio/AudioManager';\r\nimport NM from 'Notification/NotificationManager';\r\nimport Input from 'Input/InputManager';\r\nimport fpscounter from 'fpscounter';\r\nimport Dom from 'Core/Dom';\r\n\r\n/**\r\n * The `Game` class is the central part to AthenaJS\r\n * \r\n * @param {Object} options\r\n * @param {boolean} [options.debug=false] Debug will be enabled if this is true.\r\n * @param {string} [options.name] The name of the game.\r\n * @param {string|HTMLElement} [options.target=\"new Dom('div')\"] target The DOM target of the game: this is where the game canvas elements will be added.\r\n * By default the target is a new Div that is appened to the body element.\r\n * @param {boolean} [options.showFps=false] A little fps counter will be displayed if this is true.\r\n * @param {number} [options.width=1024] The width of the game display.\r\n * @param {number} [options.height=768] The height of the game display.\r\n * @param {Object} [options.resources] An optionnal array of resources of the form:``{ id: 'unique id', type: 'image|script|map|audio', src: 'path_to_resource'}`` that the scene needs.\r\n * \r\n */    \r\nclass Game{\r\n    constructor(options = {}) {\r\n        console.log('[Game] Init()'/*, options*/);\r\n\r\n        this.debug = options.debug;\r\n        this.name = options.name;\r\n\r\n        const target = options.target && new Dom(options.target);\r\n\r\n        // DOM element to use for the game (it will be cleared)\r\n        this.target = target && target.length && target[0] || new Dom('div').appendTo('body')[0];\r\n\r\n        // weather to display FPS\r\n        this.showFps = typeof options.showFps !== 'undefined' ? options.showFps : false;\r\n\r\n        if (this.showFps) {\r\n            fpscounter({\r\n                    width: 50,\r\n                    height: 50\r\n            });\r\n        }\r\n\r\n        this.width = options.width || 1024;\r\n        this.height = options.height || 768;\r\n\r\n        this.resources = options.resources;\r\n\r\n        // current display\r\n        this.display = null;\r\n\r\n        // current scene\r\n        this.scene = null;\r\n\r\n        this.running = false;\r\n\r\n        // get ready for input events\r\n        this._initEvents();\r\n\r\n        // creates the main display\r\n        this.createDisplay({\r\n            name: 'main',\r\n            width: options.width,\r\n            height: options.height,\r\n            numLayers: options.numLayers || 2\r\n        }, this.target);\r\n\r\n        this.toggleSound(typeof options.sound !== 'undefined' ? options.sound : true);\r\n\r\n        if (!!options.sound === false) {\r\n            console.warn('sound disabled: skipping audio resources');\r\n            ResourceManager.skipResources.push('audio');\r\n        }\r\n\r\n        // eventLoop timeout\r\n        this.timeout = null;\r\n\r\n        // rendering loop\r\n        this.animFrame = null;\r\n\r\n        // listen for all events\r\n        this.bindEvents('*');\r\n    }\r\n\r\n\r\n    /**\r\n     * Get ready for events from NotificationManager\r\n     * \r\n     * @param {String} eventList space-separated list of events to listen to\r\n     * \r\n     */\r\n    bindEvents(eventList) {\r\n        NM.listen(eventList, this.onEvent.bind(this));\r\n    }\r\n\r\n\r\n    /**\r\n     * Method that gets called when receiving an event: by default it does nothing\r\n     * It's up to the developer to overwrite this method on its Game\r\n     * \r\n     * @param {string} event the event name that got fired.\r\n     * \r\n     */\r\n    onEvent(event) {\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Toggles global sound\r\n     * \r\n     * @param {boolean} bool Weather to enable or disable sound.\r\n     * \r\n     */\r\n    toggleSound(bool) {\r\n        this.sound = bool;\r\n        AudioManager.toggleSound(bool);\r\n    }\r\n\r\n\r\n    /**\r\n     * Load resources associated with the game\r\n     * TODO: DESCRIBE\r\n     * \r\n     * @param {array} res An array of resources to load.\r\n     * @param {function} [progressCb=undefined] A progress callback function that gets called after each resource has been loaded\r\n     * @returns {Deferred} `this.readyDef`\r\n     * @obsolete\r\n     * \r\n     */\r\n    // loadResources(res, progressCb/*, doneCb, failCb*/) {\r\n    //     console.log('[Game] loading Resources...');\r\n    //     this.readyDef = ResourceManager.addResources(res);\r\n\r\n    //     // this.readyDef.done(this.cacheImages.bind(this));\r\n\r\n    //     ResourceManager.loadResources('any', progressCb);\r\n\r\n    //     return this.readyDef;\r\n    // }\r\n\r\n\r\n    /**\r\n     * Creates a new display\r\n     * \r\n     * TODO: DESCRIBE\r\n     * @param {Object}\r\n     * @param {String|HTMLElement} The target of the display: this is were canvas elements will be added\r\n     * @private\r\n     * \r\n     */\r\n    createDisplay(options, target) {\r\n        this.display = DisplayManager.addDisplay(options, target);\r\n    }\r\n\r\n\r\n    /**\r\n     * INTERNAL: initialize input events\r\n     * @private\r\n     */\r\n    _initEvents() {\r\n        Input._init(this, {\r\n            joystick: true\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Calls when game is ready: DESCRIBE\r\n     * \r\n     * @param {any} cb \r\n     * \r\n     */\r\n    onReady(cb) {\r\n        console.log('**this', this);\r\n        cb.apply(this);\r\n    }\r\n\r\n\r\n    /**\r\n     * Sets a new scene as the current scene, autostarting it optionnaly\r\n     * \r\n     * @param {Scene} scene instance to set as current Scene\r\n     * @param {Boolean} autoStart should the scene autostart\r\n     * \r\n     */\r\n    setScene(scene, autoStart) {\r\n        if (this.scene) {\r\n            console.log('need to stop scene');\r\n            this.stopScene();\r\n            this.scene.stop();\r\n        }\r\n        \r\n        if (scene) {\r\n            debugger;\r\n            this.scene = scene;\r\n\r\n            this.scene.setDisplay(this.display);\r\n\r\n            this.display.clearDisplay();\r\n\r\n            console.log('**autoStart', autoStart);\r\n            if (autoStart !== false) {\r\n                this.startScene();\r\n            } else {\r\n                debugger;\r\n            }\r\n        } else {\r\n            console.warn('attempt to set non-existing scene:', scene);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This is the render scene loop that's get called at up to 60 times per second\r\n     * \r\n     * @param {any} time since last frame was rendered\r\n     * \r\n     * @private\r\n     */\r\n    _renderSceneLoop(time) {\r\n        var scene = this.scene;\r\n\r\n        if (this.debug !== true && this.running) {\r\n            // if we are playing events, set on each frame\r\n            // TODO: maybe we could throttle it for 1/2 frame\r\n            if (Input.playingEvents) {\r\n                Input.nextRecordedEvents();\r\n            }\r\n\r\n            this.animFrame = window.requestAnimationFrame(this._renderSceneLoop.bind(this));\r\n\r\n            this.display.renderScene(scene);\r\n\r\n            // TODO: hudScene drawing is hardcoded into display\r\n            // this should be moved back here\r\n            if (scene.hudScene) {\r\n                // use another display (canvas) for the hud: we could use the same one\r\n                // this.display.renderSecondary(scene.hudScene);\r\n                //\r\n                // this.display.renderScene(scene.hudScene);\r\n            }\r\n\r\n            // if we are recording events, we do it on each frame\r\n            // TODO: maybe we could only record once key has been received ?\r\n            if (Input.recording) {\r\n                Input.recordEvents();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Main event loop: handles scene based-events\r\n     * \r\n     * @private\r\n     */\r\n    _runSceneLoop() {\r\n        let scene = this.scene;\r\n\r\n        if (!this.running) {\r\n            this.running = true;\r\n        }\r\n\r\n        scene.run();\r\n\r\n        if (this.debug !== true && this.running) {\r\n            this.timeout = setTimeout(this._runSceneLoop.bind(this), 16);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pauses the game: both loops are stopped so almost no cpu/gpu is used when calling it\r\n     * \r\n     */\r\n    togglePauseGame() {\r\n        if (this.running) {\r\n            console.log('pausing game');\r\n            this.running = false;\r\n            this.scene.pause();\r\n\r\n            // be sure to render any changes from the scene before stopping refresh\r\n            this.display.renderScene(this.scene);\r\n\r\n            // then stop render/event loop\r\n            this.stopScene();\r\n        } else {\r\n            console.log('un-pausing game');\r\n            this.running = true;\r\n            this.scene.unpause();\r\n            this._runSceneLoop();\r\n            this._renderSceneLoop();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts the current scene\r\n     * \r\n     * - loads the scene if not already loaded\r\n     * - once it's loaded calls scene.start() and start both event & render loops\r\n     * \r\n     */\r\n    startScene() {\r\n        console.log('[Game] startScene');\r\n        var that = this;\r\n\r\n        if (this.scene) {\r\n            console.log('[Game] loading scene');\r\n            this.scene.load().then(() => {\r\n                console.log('[Game] Scene', that.scene.name, 'loaded: starting run & render loops');\r\n                // setTimeout(function() {\r\n                    debugger;\r\n                    that.scene.start();\r\n                    debugger;\r\n                    that._runSceneLoop();\r\n                    that._renderSceneLoop();\r\n                // }, 0);\r\n            });\r\n        } else {\r\n            console.log('[Game] nothing to start: no scene selected!!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops current scene from running: this will both halt render & event loops\r\n     * \r\n     * Use Game.togglePauseGame() to temporarly pause a game\r\n     * \r\n     */\r\n    stopScene() {\r\n        this.running = false;\r\n\r\n        console.log('[Game] Scene stopped, stopping run & render loops');\r\n\r\n        if (this.animFrame) {\r\n            window.cancelAnimationFrame(this.animFrame);\r\n            this.animFrame = null;\r\n        }\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nexport default Game;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Core/Game.js","import Effect from 'FX/Effect/Effect';\n\n    /*jshint devel: true, bitwise: false*/\n    class Custom extends Effect{\n        constructor(options, display) {\n            super(options, display);\n\n            this.callback = options.callback;\n\n            this.diff = this.endValue - this.startValue;\n        }\n/*        start: function() {\n            this.currentAngle = this.startAngle;\n\n            // start timer and get deferred\n            return this._super();\n        },*/\n        process(ctx, fxCtx, obj) {\n            super.process();\n\n            this.callback(this.startValue + this.animProgress * this.diff);\n\n            return this.ended;\n        }\n    };\n\n    export default Custom;\n\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Effect/Custom.js","import Effect from 'FX/Effect/Effect';\n\n\n    /*jshint devel: true, bitwise: false*/\n    class Fade extends Effect{\n        constructor(options, display) {\n            super(Object.assign({\n                startValue: 0,\n                endValue: 1\n            }, options), display);\n\n            this.startOpacity = this.startValue !== undefined ? options.startValue : 0;\n            this.endOpacity = this.endValue !== undefined ? options.endValue : 1;\n\n            this.diff = this.endValue - this.startValue;\n        }\n        \n        start() {\n            this.currentOpacity = 1;\n\n            // start timer and get deferred\n            return super.start();\n        }\n        \n        process(ctx, fxCtx, obj) {\n            super.process();\n\n            this.currentOpacity = this.startValue + this.animProgress * this.diff;\n\n            obj.setOpacity(this.currentOpacity);\n\n            return this.ended;\n        }\n    };\n\n    export default Fade;\n\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Effect/Fade.js","import Effect from 'FX/Effect/Effect';\n\n    /*jshint devel: true, bitwise: false*/\n    class Mosaic extends Effect{\n        constructor (options, display) {\n            super(Object.assign({\n                startValue: 0.002,\n                endValue: 1\n            }, options), display);\n\n            // TODO: use displayManager to get a buffer\n            this.buffer = display.getBuffer(this.width, this.height);\n\n            this.startWidth = null;\n\n            // get ratio of the picture since we want to keep it during animation\n            this.ratio = this.width / this.height;\n            this.diff = (this.endValue * this.width) - (this.startValue * this.width);\n\n            console.log('got ratio=', this.ratio, 'for', this.width, this.height, 'diff', this.diff);\n        }\n\n        start() {\n            this.startWidth = this.startValue * this.width;\n            console.log('***', this.startWidth);\n\n            return super.start();\n        }\n\n        process(ctx, fxCtx) {\n            super.process();\n\n            var newWidth = this.startWidth  + this.animProgress * this.diff,\n                newHeight = newWidth / this.ratio;\n\n            // first draw image onto canvas\n            this.buffer.drawImage(ctx.canvas, 0, 0, newWidth | 0, newHeight | 0);\n            ctx.drawImage(this.buffer.canvas, 0, 0, newWidth | 0, newHeight | 0, 0, 0, this.width, this.height);\n\n            return this.ended;\n        }\n    }\n\nexport default Mosaic;\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Effect/Mosaic.js","import Effect from 'FX/Effect/Effect';\n\n    /*jshint devel: true, bitwise: false*/\n    class Rotate extends Effect{\n        constructor(options, display) {\n            super(Object.assign({\n                startValue: 0,\n                endValue: 2*Math.PI,\n                loop: true\n            }, options), display);\n\n            this.startAngle = this.startAngle !== undefined ? options.startValue : 0;\n            this.endAngle = this.endAngle !== undefined ? options.endValue : 1;\n\n            this.diff = this.endValue - this.startValue;\n        }\n        \n        start() {\n            this.currentAngle = this.startAngle;\n\n            // start timer and get deferred\n            return super.start();\n        }\n        \n        process(ctx, fxCtx, obj) {\n            super.process();\n\n            this.currentAngle = this.startValue + this.animProgress * this.diff;\n\n            obj.setAngle(this.currentAngle);\n\n            return this.ended;\n        }\n    };\n\n    export default Rotate;\n\n\n\n// WEBPACK FOOTER //\n// ./js/FX/Effect/Rotate.js","import GroundMove from 'Object/Behavior/GroundMove';\r\nimport SimpleFall from 'Object/Behavior/SimpleFall';\r\nimport PlayerMove from 'Object/Behavior/PlayerMove';\r\nimport InOut from 'Object/Behavior/InOut';\r\nimport Path from 'Object/Behavior/Path';\r\nimport WeaponMove from 'Object/Behavior/WeaponMove';\r\n \r\n    /*jshint devel: true, bitwise: false*/   \r\n    let behaviors = {};\r\n\r\n    class Behaviors {\r\n        constructor() {}\r\n        \r\n        addBehavior(behaviorName, moveFn) {\r\n            behaviors[behaviorName] = moveFn;\r\n        }\r\n\r\n        getBehavior(behaviorName) {\r\n            return behaviors[behaviorName];\r\n        }\r\n    };\r\n    \r\n    let inst = new Behaviors();\r\n\r\n    inst.addBehavior('ground', GroundMove);\r\n    inst.addBehavior('inout', InOut);\r\n    inst.addBehavior('simplefall', SimpleFall);\r\n    inst.addBehavior('weapon', WeaponMove);\r\n    inst.addBehavior('player', PlayerMove);\r\n    inst.addBehavior('path', Path);\r\n\r\n    export default inst;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/Behaviors.js","import Behavior from 'Object/Behavior/Behavior';\nimport Tile from 'Map/Tile';\n\n    /*jshint devel: true, bitwise: false*/\n    // by default\n    /**\n     * GroundMove is a simple behavior that causes an object to move along the horizontal\n     * axis until a wall or an hole is reached.\n     * \n     * @param {Sprite} sprite The sprite to attach the behavior to.\n     * @param {InputManager} Input A reference to the InputManager.\n     * @param {Object} options General behavior & GroundMove specific options\n     * @param {String} [options.direction=\"right\"] The initial direction of the move, default = `right`.\n     * \n     * @see {Behavior}\n     */\n    class GroundMove extends Behavior {\n        constructor(sprite, Input, options) {\n            super(sprite, Input, options);\n\n            this.direction = options.direction || 'right';\n\n            if (this.direction.match('left')) {\n                this.sprite.vx = -this.sprite.vx;\n            }\n\n            if (this.direction.match('top')) {\n                this.sprite.vy = -this.sprite.vy;\n            }\n        }\n        \n        /**\n         * Simple onMove handler that checks for a wall or hole\n         * \n         */\n        onMove(t) {\n            let sprite = this.sprite,\n                map = sprite.currentMap,\n                nextX = sprite.x + sprite.vx,\n                nextY = sprite.y + sprite.vy,\n                hitBox = sprite.getHitBox(),\n                startX = sprite.vx > 0 ? hitBox.x2 : hitBox.x;\n\n            if (map.hitObjectTest(nextX + startX, nextY + hitBox.y, nextX + startX, nextY + hitBox.y, Tile.TYPE.WALL)) {\n                sprite.vx = -sprite.vx;\n                if (this.onVXChange) {\n                    this.onVXChange(sprite.vx);\n                }\n            } else if (map.hitObjectTest(nextX + hitBox.x, nextY + hitBox.y2 + 2, nextX + hitBox.x2, nextY + hitBox.y2 + 2, Tile.TYPE.AIR)) {\n                sprite.vx = -sprite.vx;\n                if (this.onVXChange) {\n                    this.onVXChange(sprite.vx);\n                }\n            } else if (map.hitObjectTest(nextX + hitBox.x, nextY + hitBox.y2 + 2, nextX + hitBox.x2, nextY + hitBox.y2 + 2, Tile.TYPE.LADDER)) {\n                sprite.vx = -sprite.vx;\n                if (this.onVXChange) {\n                    this.onVXChange(sprite.vx);\n                }\n\t\t\t      }\n\n            sprite.x += sprite.vx;\n            sprite.y += sprite.vy;\n        }\n    }\n\n    export default GroundMove;\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/GroundMove.js","import Behavior from 'Object/Behavior/Behavior';\n\n    /*jshint devel: true, bitwise: false*/   \n    // by default\n    class InOut extends Behavior{\n        constructor(sprite, Input, options) {\n            super(sprite, Input, options);\n\n            this.startY = sprite.y;\n            this.startX = sprite.x;\n\n            this.maxX = options.minX || 0;\n\n            this.maxY = options.minY || 0;\n        }\n        \n        onMove(t) {\n            let sprite = this.sprite,\n              diffY = Math.abs(sprite.y-this.startY),\n              diffX = Math.abs(sprite.x-this.startX);\n\n            if (diffY > this.maxY) {\n                sprite.vy = -sprite.vy;\n                if (this.onVYChange) {\n                    this.onVYChange();\n                }\n            }\n\n            if (diffX > this.maxX) {\n                sprite.vx = -sprite.vx;\n                if (this.onVXChange) {\n                    this.onVXChange();\n                }\n            }\n\n            sprite.x += sprite.vx;\n            sprite.y += sprite.vy;\n        }\n    };\n\n    export default InOut;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/InOut.js","import Behavior from 'Object/Behavior/Behavior';\n\n    /*jshint devel: true, bitwise: false*/\n\n    function sign(x) {\n        return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : x === x ? 0 : NaN : NaN;\n    }\n\n    /**\n     * A Path is a special behavior that uses a pre-defined (recorded) path to move\n     * an object.\n     * \n     * @param {Sprite} sprite The sprite to attach the behavior to.\n     * @param {InputManager} Input A reference to the InputManager.\n     * @param {Object} options The options of the behavior.\n     * @param {Array} options.nodes The nodes of the path: a simple array with nodes[0] = vx, nodes[1] = vy, nodes[2] = vx, nodes[3] = vy,...\n     * @param {Boolean} options.reverse Set to true so that when the end of the path is reached, movement goes backwards.\n     * \n     * @see {Behavior}\n     */\n    class Path extends Behavior {\n        constructor(sprite, Input, options) {\n            super(sprite, Input, options);\n\n            this.startY = sprite.y;\n            this.startX = sprite.x;\n\n            this.currentNode = 0;\n\n            this.offset = 2;\n\n            this.nodes = options.nodes;\n\n            this.reverse = options.reverse || false;\n\n            this.dirX = 0;\n            this.dirY = 0;\n\n            this.numNodes = this.nodes.length / 2;\n        }\n        \n        /**\n         * Move handler: gets the next vx/vy from `this.nodes`\n         * and makes sure to call onVXChange/onVYChange at each sign change\n         */\n        onMove(t) {\n            let sprite = this.sprite,\n                pos = this.currentNode,\n                offsetX = this.nodes[pos],\n                offsetY = this.nodes[pos + 1];\n\n            if (this.offset > 0) {\n                sprite.x += offsetX;\n                sprite.y += offsetY;\n            } else {\n                sprite.x -= offsetX;\n                sprite.y -= offsetY;\n            }\n\n            if (offsetX) {\n                if (this.dirX && (sign(this.dirX) !== sign(offsetX))) {\n                    this.onVXChange && this.onVXChange();\n                }\n                this.dirX = offsetX;\n            }\n\n            if (offsetY) {\n                if (this.dirY && (sign(this.dirY) !== sign(offsetY))) {\n                    this.onVYChange && this.onVYChange();\n                }\n                this.dirY = offsetY;\n            }\n\n            this.currentNode += this.offset;\n\n            if (this.currentNode >= this.nodes.length || this.currentNode < 0)  {\n                if (!this.reverse) {\n                    sprite.moving = false;\n                    return;\n                } else {\n                    if (this.onVXChange) {\n                        this.dirX = 0;\n                        this.onVXChange();\n                    }\n\n                    if (this.onVYChange) {\n                        this.dirY = 0;\n                        this.onVYChange();\n                    }\n                    this.currentNode = this.currentNode < 0 ? 0 : (this.nodes.length - 2);\n                    this.offset = -this.offset;\n                }\n            }\n        }\n    };\n\n    export default Path;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/Path.js","import Behavior from 'Object/Behavior/Behavior';\r\nimport AM from 'Audio/AudioManager';\r\nimport Tile from 'Map/Tile';\r\n\r\n    /*jshint devel: true, bitwise: false*/\r\n    /*globals Game*/\r\n\r\n    /**\r\n     * PlayerMove is a behavior that is controlled by the player using keyboard/touch events.\r\n     * \r\n     * To have a sprite controlled by the user you can simply attach this behavior.\r\n     * \r\n     * @param {Sprite} sprite The sprite to attach the behavior to.\r\n     * @param {InputManager} Input A reference to the InputManager\r\n     * @param {Object} options Parameters specifics to the behavior\r\n     * @param {String} [options.startMovement=\"idle\"\"] The initial behavior state.\r\n     * @param {String} [options.direction=\"right\"] The initial direction.\r\n     * @param {String} [options.lookDirection=\"left\"] The initial look direction, can be different than direction.\r\n     * \r\n     * @see {Behavior}\r\n     */\r\n    class PlayerMove extends Behavior {\r\n        constructor(sprite, Input, options) {\r\n            super(sprite, Input, options);\r\n\r\n            this.direction = options.direction || 'right';\r\n\r\n            this.currentMovement = options.startMovement || '';\r\n\r\n            this.lookDirection = options.lookDirection || 'left';\r\n\r\n            this.climbVY = 2;\r\n            \r\n            this.jumping = false;\r\n            \r\n            this.firing = false;\r\n            \r\n            this.fromLadder = false;\r\n\r\n\t\t\tthis.sideHit = false;\r\n        }\r\n        \r\n        /**\r\n         * onMove handler: uses InputManager to get keyboard status and move the sprite when needed\r\n         * \r\n         * @param {Number} t The time ellapsed since last move\r\n         */\r\n        onMove(t) {\r\n            let Input = this.Input;\r\n\r\n            if (this.currentMovement !== 'falling' && !this.currentMovement.match(/jump/) && !this.firing) {\r\n                // console.log('left', Input.getKeyStatus(Input.keys.LEFT));\r\n                // direction\r\n                if (Input.getKeyStatus(Input.keys.LEFT) === true) {\r\n                    if (Input.getKeyStatus(Input.keys.UP) === true) {\r\n                        this.startJump('left');\r\n                    } else {\r\n                        this.walkLeft();\r\n                    }\r\n                } else if (Input.getKeyStatus(Input.keys.RIGHT) === true) {\r\n                    if (Input.getKeyStatus(Input.keys.UP) === true) {\r\n                        this.startJump('right');\r\n                        console.log('startJump right', this.fromLadder);\r\n                    } else {\r\n                        this.walkRight();\r\n                    }\r\n                } else if (Input.getKeyStatus(Input.keys.UP) === true) {\r\n                    this.goUpOrClimb(false);\r\n                } else if (Input.getKeyStatus(Input.keys.DOWN) === true) {\r\n                    // empty ? => fall (possible ?)\r\n                    this.goDownOrClimb(0);\r\n                } else {\r\n                    if (this.currentMovement !== 'climb') {\r\n                      if (!this.currentMovement.match('fire')) {\r\n                        this.idle();\r\n                      }\r\n                    } else {\r\n                        this.stopClimbing();\r\n                    }\r\n                }\r\n\r\n                // fire (we may fire while jumping/moving)\r\n                if (Input.getKeyStatus(Input.keys.CTRL, true) === true) {\r\n                    switch(this.currentMovement) {\r\n                        case 'faceWall':\r\n                            if (this.switchAbove) {\r\n                              this.getMapEvent().handleAction({\r\n                                type: 'toggleSwitch',\r\n                                sprite: this.switchAbove\r\n                              });\r\n                            }\r\n                            break;\r\n\r\n                        case 'climb':\r\n                            if (!this.lookDirection) {\r\n                                break;\r\n                            }\r\n                        case 'idle':\r\n                            case 'walk_right':\r\n                            case 'walk_left':\r\n                                this.handleFire();\r\n\t\t\t\t\t\t\t    break;\r\n                            \r\n                        case 'down':\r\n                            // inventory\r\n                            break;\r\n                        \r\n                        default:\r\n                          console.log('unhandle fire');\r\n                          console.log(this.currentMovement);\r\n                          break;\r\n                      }\r\n                }\r\n            } else {\r\n                if (this.currentMovement.match(/jump/)) {\r\n                    // console.log('***', this.currentMovement, Input.getKeyStatus(Input.keys.SPACE, true));\r\n                    if (Input.getKeyStatus(Input.keys.CTRL, true)) {\r\n                        this.handleFire();\r\n                    }\r\n                    // TODO: handle up key to catch the ladder\r\n                    if (!this.fromLadder && Input.getKeyStatus(Input.keys.UP) === true && !this.goUpOrClimb(true)) {\r\n                        this.jump(this.lookDirection);\r\n                    } else {\r\n                        // console.log('jump 2');\r\n                        this.jump(this.lookDirection);\r\n                    }\r\n                } else if (!this.currentMovement.match('fire') && !this.currentMovement.match('climb')) {\r\n                    console.log('cas 2.2', this.currentMovement);\r\n                    this.fall();\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the player attemps to fire\r\n         * \r\n         * @private\r\n         */\r\n        handleFire() {\r\n            let canFire = false,\r\n                that = this;\r\n\r\n            console.log('fire direction', this.lookDirection);\r\n            \r\n            if (this.firing) {\r\n                return;\r\n            }\r\n            \r\n            // TODO: right/left ?\r\n            canFire = this.sprite.onEvent('fire', {\r\n                direction: this.lookDirection\r\n            });\r\n\r\n            if (canFire) {\r\n                this.firing = true;\r\n                \r\n                // player can fire & move only after fire animation has completed\r\n                this.previousMovement = this.currentMovement;\r\n                this.sprite.storeCurrentAnim();\r\n                this.sprite.setAnimation('fire' + this.lookDirection, function() {\r\n                    that.firing = false;\r\n                    this.restorePreviousAnim();\r\n                });\r\n                // this.currentMovement = 'fire' + dir;\r\n                // if (!this.previousMovement.match(/jump/)) {\r\n                //    this.currentMovement = 'fire' + this.lookDirection;\r\n                // }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the player is walking\r\n         * \r\n         * @param {String} direction The direction the player is heading at.\r\n         * \r\n         * @private\r\n         */\r\n        walk(direction) {\r\n\t\t\t// ADD: this.currentMovement = 'walk_left|right'\r\n            let sprite = this.sprite,\r\n                currentHitBox = sprite.getHitBox(),\r\n                nextX,\r\n                nextY,\r\n                sound;\r\n\r\n            this.currentMovement = 'walk_' + direction;\r\n\r\n            this.vy = 0;\r\n            sprite.currentAnimName = 'walk' + direction.charAt(0).toUpperCase() + direction.slice(1);\r\n            sound = 'step_' + direction;\r\n            this.lookDirection = direction;\r\n\r\n            if (direction === 'left') {\r\n                this.vx = -2;\r\n            } else {\r\n                this.vx = 2;\r\n            }\r\n\r\n            nextX = sprite.x + this.vx;\r\n            nextY = sprite.y + this.vy;\r\n\r\n            // hit wall ?\r\n            if (!sprite.currentMap.hitObjectTest(nextX + currentHitBox.x, nextY + currentHitBox.y, nextX + currentHitBox.x2, nextY + currentHitBox.y2, Tile.TYPE.WALL)) {\r\n                sprite.startAnimation();\r\n                if (sprite.currentFrameNum !== sprite.previousFrameNum && (sprite.currentFrameNum === 3 || sprite.currentFrameNum === 7)) {\r\n                    AM.play(sound);\r\n                }\r\n            } else {\r\n                this.idle();\r\n            }\r\n\r\n            sprite.x += this.vx;\r\n            sprite.y += this.vy;\r\n\r\n            this.fallTest();\r\n\r\n            return 0;\r\n        }\r\n        \r\n        /**\r\n         * Called when player needs to walk on the left\r\n         * \r\n         * @private\r\n         */\r\n        walkLeft() {\r\n            if (this.currentMovement !== 'climb') {\r\n                this.walk('left');\r\n            } else {\r\n                this.lookDirection = 'left';\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when player needs to walk on the right\r\n         * \r\n         * Lots of hardcoded constants that would be better off as behavior options\r\n         * \r\n         * @private\r\n         */\r\n        walkRight() {\r\n            if (this.currentMovement !== 'climb') {\r\n                this.walk('right');\r\n            } else {\r\n                this.lookDirection = 'right';\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the play starts jumping\r\n         * \r\n         * @param {String} direction The direction of the jump (right or left).\r\n         * \r\n         * @private\r\n         */\r\n        startJump(direction) {\r\n          let sprite = this.sprite,\r\n              that = this;\r\n    \r\n                if (!this.jumping) {\r\n                    console.log('starting jump', sprite.y);\r\n                    this.readyToJump = false;\r\n                    this.currentMovement = 'startjump';\r\n                    this.vx = direction === 'left' ? -2 : 2;\r\n                    this.vy = -4;\r\n                    this.gravity  = 0.098;\r\n                    \r\n                    console.log('startJump', this.vy);\r\n                    \r\n                    sprite.setAnimation('goDown' + direction, function() {\r\n                        console.log('end goDownLeft, ready to jump', this.vy, this.y);\r\n                        that.readyToJump = true;\r\n                        that.currentMovement = 'jump' + direction;\r\n                        that.jumping = true;\r\n                        \r\n                        // TODO: call onEvent('jump')\r\n                        this.setAnimation('jump' + direction);\r\n                    });                \r\n                }\r\n                else {\r\n                    that.readyToJump = true;\r\n                    this.jumping = true;\r\n                    that.currentMovement = 'jump' + direction;\r\n    \r\n                    this.vx = direction === 'left' ? -2 : 2;\r\n                    this.vy = -4;\r\n                    this.gravity  = 0.098;                \r\n                    \r\n                    // TODO: call onEvent('jump')\r\n                    this.sprite.setAnimation('jump' + direction);                \r\n                }\r\n    \r\n                this.lookDirection = this.direction = direction;\r\n                this.sideHit = false;            \r\n    \r\n                AM.play('jump');\r\n        }\r\n\r\n        /**\r\n         * Called when the playing is already jumping: this method is checks for colisions and\r\n         * calculates next x/y sprite position\r\n         * \r\n         * @param {String} direction The direction of the jump.\r\n         * \r\n         * @private\r\n         */\r\n        jump(direction) {\r\n            let sprite = this.sprite,\r\n                nextX = sprite.x + Math.ceil(this.vx),\r\n                nextY = sprite.y + Math.ceil(this.vy),\r\n                currentHitBox = sprite.getHitBox(),\r\n                horizTileHit = null,\r\n                vertTileHit = null,\r\n                noVx = false,\r\n                noVy = false;\r\n\r\n            if (!this.readyToJump) {\r\n              console.log('not ready to jump', this.fromLadder);\r\n              return;\r\n            }\r\n\r\n            if (this.currentMovement.match(/jump/)) {\r\n                horizTileHit = sprite.currentMap.hitObjectTest(nextX + currentHitBox.x, sprite.y + currentHitBox.y, nextX + currentHitBox.x2, sprite.y + currentHitBox.y2, Tile.TYPE.WALL);\r\n                // left/right collision ? => vx = 0, but player continues to go up\r\n                if (horizTileHit) {\r\n                    // debugger;\r\n                    // console.log('[PlayerMove] Left/Right collision!');\r\n\r\n                    // this.vx = 0;\r\n\t\t\t\t\t         this.sideHit = true;\r\n\t\t\t\t\t         noVx = true;\r\n\r\n                    // set x to max(wall, nextx), which is wall-1\r\n                    if (this.direction === 'right') {\r\n                        sprite.x = horizTileHit.tile.x -currentHitBox.x2 -currentHitBox.x -1;\r\n                    } else {\r\n                        sprite.x = horizTileHit.tile.x + sprite.currentMap.tileWidth;\r\n                    }\r\n\r\n                }/* else if (!this.fromLadder && this.sideHit === true) {\r\n\t\t\t\t\t// side was hit during jump\r\n\t\t\t\t\tnoVy = true;\r\n                    this.currentMovement = '';\r\n\t\t\t\t\tAM.play('land');\r\n                }*/\r\n                // top/down collision\r\n\t\t\t\t        vertTileHit = sprite.currentMap.hitObjectTest(sprite.x + currentHitBox.x, nextY + currentHitBox.y, sprite.x + currentHitBox.x2, nextY + currentHitBox.y2, Tile.TYPE.WALL);\r\n                // top/bottom collision ? => fall\r\n                if (vertTileHit) {\r\n                    // top\r\n                    if (this.vy < 0) {\r\n                        // debugger;\r\n                        console.log('[PlayerMove] Top collision, reversing vy!');\r\n                        if (!this.sideHit) {\r\n                            this.fall();\r\n                        } else {\r\n                            this.vy = -this.vy;\r\n                            // ** this.vx = 0;\r\n                        }\r\n                        return;\r\n                    } else {    // ground touched\r\n                        console.log('[PlayerMove] touch ground!', this.currentMovement);\r\n                        // debugger;\r\n                        this.jumping = false;\r\n                        this.fromLadder = false;\r\n\r\n                        // TODO: play endJumLeft animation => onAnimationEnd, readyLeft\r\n\t\t\t            AM.play('land');\r\n                        this.currentMovement = 'idle';\r\n\r\n\t\t\t            sprite.y = vertTileHit.tile.y - sprite.getCurrentHeight();\r\n                        this.vy = 0;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!noVx) {\r\n              sprite.x += Math.ceil(this.vx);\r\n            }\r\n            if (!noVy) {\r\n              sprite.y += Math.ceil(this.vy);\r\n              this.vy += this.gravity;\r\n            } else {\r\n              this.vy = 0;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the player stops moving\r\n         * \r\n         * @private\r\n         */\r\n        idle() {\r\n            let sprite = this.sprite;\r\n\r\n            this.vx = 0;\r\n            this.vy = 0;\r\n\t\t\t\r\n            sprite.stopAnimation();\r\n        }\r\n        \r\n        /**\r\n         * Called when the player needs to goDown\r\n         * \r\n         * @private\r\n         */\r\n        goDown() {\r\n            let sprite = this.sprite;\r\n            this.vx = 0;\r\n            this.vy = 0;\r\n\r\n            sprite.currentAnimName = 'goDown' + this.lookDirection;\r\n\r\n            this.currentMovement = '';\r\n        }\r\n        \r\n        /**\r\n         * Called when the player faces the wall\r\n         * \r\n         * @private\r\n         */\r\n        faceWall() {\r\n            let sprite = this.sprite;\r\n\r\n            this.vx = 0;\r\n            this.vy = 0;\r\n\r\n            // only check once\r\n            if (this.currentMovement !== 'faceWall') {\r\n                this.currentMovement = 'faceWall';\r\n                sprite.advanceFrame('faceWall');\r\n                this.switchAbove = this.sprite.currentMap.getSwitchAboveMaster();\r\n                console.log('**** faceWall', this.switchAbove);\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the player starts climbing a ladder\r\n         * \r\n         * @param {Number} direction The direction, can be 0 (down) or 1 (up)\r\n         * \r\n         * @private\r\n         */\r\n        climb(direction) {\r\n            console.log('climbing');\r\n            let sprite = this.sprite;\r\n\r\n            this.fromLadder = true;\r\n\r\n            this.currentMovement = 'climb';\r\n            this.vx = 0;\r\n            this.vy = direction ? -this.climbVY : this.climbVY;\r\n\r\n            sprite.currentAnimName = 'climb';\r\n            sprite.startAnimation();\r\n\r\n            // TODO: check for top ladder or floor\r\n\r\n            sprite.x += this.vx;\r\n            sprite.y += this.vy;\r\n        }\r\n        \r\n        /**\r\n         * Called when the player stops climbing (ie: released up/down keys)\r\n         * \r\n         * @private\r\n         */\r\n        stopClimbing(/*direction*/) {\r\n            let sprite = this.sprite;\r\n\r\n            this.vx = 0;\r\n            this.vy = 0;\r\n            sprite.stopAnimation();\r\n        }\r\n        \r\n        /**\r\n         * Called when the player moves the up arrow key: depending on its position he will face a wall\r\n         * or climb a ladder\r\n         * \r\n         * @param {Boolean} onlyClimb Set to true to only climb\r\n         * \r\n         * @private\r\n         */\r\n        goUpOrClimb(onlyClimb) {\r\n            let sprite = this.sprite,\r\n                currentHitBox = sprite.getHitBox(),\r\n                diff = onlyClimb ? 0 : 24,\r\n                pos = false,\r\n                pos2 = false,\r\n                Input = this.Input;\r\n\r\n            if (Input.getKeyStatus(Input.keys.LEFT) === true || Input.getKeyStatus(Input.keys.RIGHT) === true) {\r\n                return false;\r\n            }\r\n            \r\n            if (onlyClimb === true) {\r\n                if (sprite.currentMap.hitObjectTest(currentHitBox.x + sprite.x, currentHitBox.y + sprite.y + 40, currentHitBox.x + sprite.x -diff, currentHitBox.y2 + sprite.y - 50, Tile.TYPE.LADDER)) {\r\n                    pos = sprite.currentMap.hitObjectTest(currentHitBox.x2 + sprite.x + diff, currentHitBox.y + sprite.y + 40, currentHitBox.x2 + sprite.x -diff, currentHitBox.y2 + sprite.y - 50, Tile.TYPE.LADDER);\r\n                }\r\n            } else {\r\n                pos = sprite.currentMap.hitObjectTest(currentHitBox.x + sprite.x + diff, currentHitBox.y + sprite.y + 40, currentHitBox.x2 + sprite.x -diff, currentHitBox.y2 + sprite.y - 50, Tile.TYPE.LADDER);\r\n            }\r\n\r\n            if (pos !== false) {\r\n                // debugger;\r\n                // center player over tile (ladder)\r\n                if (this.currentMovement !== 'climb') {\r\n                    // debugger;\r\n                    sprite.centerXOverTile(pos);\r\n                    this.lookDirection = '';\r\n                }\r\n                console.log('climbing, fromLadder', this.fromLadder, this.currentMovement);\r\n                this.climb(1);\r\n\r\n                return true;\r\n            } else if (!onlyClimb) {\r\n                // TODO: if (climb) anim(faceLadder)\r\n                this.faceWall();\r\n\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * This method is called when the player presses the down arrow key: depending on its position,\r\n         * player will climb a ladder or get down\r\n         * \r\n         * @private\r\n         */\r\n        goDownOrClimb() {\r\n            let sprite = this.sprite,\r\n                currentHitBox = sprite.getHitBox(),\r\n\t\t\t\tpos = sprite.currentMap.hitObjectTest(currentHitBox.x + sprite.x + 24, currentHitBox.y2 + sprite.y + this.climbVY, currentHitBox.x2 + sprite.x -24, currentHitBox.y2 + sprite.y + this.climbVY, Tile.TYPE.LADDER);\r\n\r\n            if (pos) {\r\n                if (this.currentMovement !== 'climb') {\r\n                    sprite.centerXOverTile(pos);\r\n                }\r\n                console.log(currentHitBox.x2 + sprite.x -24, currentHitBox.y2 + sprite.y + this.climbVY);\r\n                this.climb(0);\r\n            } else {\r\n                // TODO: if (climb) anim(faceLadder)\r\n                if (this.currentMovement === 'climb' || this.currentMovement === 'faceWall') {\r\n                    // debugger;\r\n                    console.log(currentHitBox.x2 + sprite.x -24, currentHitBox.y2 + sprite.y + this.climbVY);\r\n                    console.log('faceWall');\r\n                    pos = sprite.currentMap.hitObjectTest(currentHitBox.x + sprite.x + 24, currentHitBox.y2 + sprite.y + this.climbVY, currentHitBox.x2 + sprite.x -24, currentHitBox.y2 + sprite.y + this.climbVY, Tile.TYPE.LADDER);\r\n                    this.faceWall();\r\n                } else {\r\n                    this.goDown();\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the player is falling\r\n         * \r\n         * @private\r\n         */\r\n        fall() {\r\n            let i = 4,\r\n                sprite = this.sprite;\r\n\r\n            this.jumping = false;\r\n            \r\n            //          AM.play('falling');\r\n            // TODO: guess movement is different if we're falling after a jump or simple walk\r\n            // console.log('fall()', this.lookDirection);\r\n            for (; i > 0; i--) {\r\n                if (this.fallTest(i)) {\r\n                    this.vy = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (i > 0) {\r\n                this.vx = 0;\r\n\t\t        sprite.y += this.vy;\r\n                sprite.advanceFrame('fall' + this.lookDirection);\r\n            } else {\r\n                this.fromLadder = false;\r\n                console.log('**land =>', this.fromLadder);\r\n                // if (this.currentMovement === 'falling') {\r\n\t\t\t    //     AM.play('land');\r\n                // }\r\n\t\t   }\r\n        }\r\n        \r\n        /**\r\n         * Checkes that player can fall\r\n         * \r\n         * @param {Number=1} size The gap size to check for.\r\n         * \r\n         * @returns {Boolean} true if the player falls\r\n         * \r\n         * @private\r\n         */\r\n        fallTest(size) {\r\n            size = size || 1;\r\n            \r\n            let sprite = this.sprite,\r\n                currentHitBox = sprite.getHitBox(),\r\n                y = sprite.y + currentHitBox.y2 + size;\r\n                \r\n            // check for falling\r\n            // var y = sprite.y + sprite.getCurrentHeight() + size;\r\n            \r\n            if (!sprite.currentMap.fallTest(sprite.x + currentHitBox.x, y) && !sprite.currentMap.fallTest(sprite.x + currentHitBox.x2, y)) {\r\n                      this.currentMovement = 'falling';\r\n                      return true;\r\n                  } else {\r\n\r\n                //                    if (this.currentMovement == 'falling') {\r\n                //                        debugger;\r\n                //                        this.currentMap.fallTest(this.x + currentHitBox.x, y) && this.currentMap.fallTest(this.x + currentHitBox.x2, y);\r\n                //                    }\r\n                if (this.currentMovement == 'falling') {\r\n                    this.currentMovement = '';\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    \r\n    export default PlayerMove;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/PlayerMove.js","import Behavior from 'Object/Behavior/Behavior';\r\nimport Tile from 'Map/Tile';\r\n\r\n    /*jshint devel: true, bitwise: false*/\r\n    /**\r\n     * Simple behavior that makes an object bounce on the ground\r\n     * \r\n     * @param {Sprite} sprite The sprite to attach the behavior to.\r\n     * @param {InputManager} Input A reference to the InputManager.\r\n     * @param {Object} options The options of the behavior.\r\n     * @param {Number} [options.elasticity=0.80] The elasticity: the closer it is to 1, the higher the bounce.\r\n     * @param {Function} [options.onEnd=undefined] An optional callback to execute when the object stops bouncing.\r\n     * @param {Function} [options.onGround=undefined] An optional callback to execute each time the object touches the ground.\r\n     * \r\n     * @example\r\n     * \r\n     *  sprite.setBehavior('simplefall', {\r\n     *    gravity: 0.3,\r\n     *    onEnd: () => {\r\n     *        this.moving = false;\r\n     *    },\r\n     *    onGround: function() {\r\n     *      AM.play('bounce');\r\n     *    }\r\n     * });\r\n     */\r\n    class SimpleFall extends Behavior{\r\n        constructor(sprite, Input, options) {\r\n            super(sprite, Input, options);\r\n\r\n            this.elasticity = typeof options.elasticity !== 'undefined' ? options.elasticity : 0.80;\r\n\r\n            this.onEnd = options.onEnd || null;\r\n            this.onGround = options.onGround || null;\r\n\r\n            console.log('move initiated', sprite.vx, sprite.vy, this.startVy, sprite.gravity);\r\n        }\r\n        \r\n        /**\r\n         * The move handler that gets executed at each move loop.\r\n         * \r\n         * Simply calculates the next vertical position using current velocity.\r\n         * Each time the object reaches the ground, it bounces a little less, using the elasticity property,\r\n         * until it reaches the ground and stops bouncing.\r\n         * \r\n         */\r\n        onMove(t) {\r\n            let sprite = this.sprite,\r\n                map = sprite.currentMap,\r\n                nextX = sprite.x + sprite.vx,\r\n                nextY = sprite.y + sprite.vy,\r\n                hitBox = sprite.getHitBox(),\r\n                hitTest = null;\r\n\r\n            // reached ground ? revert vy\r\n            hitTest = map.hitObjectTest(nextX + hitBox.x, nextY + hitBox.y2, nextX + hitBox.x2, nextY + hitBox.y2, Tile.TYPE.WALL);\r\n            if (hitTest) {\r\n              if (this.onGround) {\r\n                this.onGround();\r\n              }\r\n                this.resetY();\r\n                if (Math.abs(sprite.vy) <= sprite.gravity) {\r\n                    sprite.moving = false;\r\n                    if (this.onEnd) {\r\n                        this.onEnd();\r\n                    }\r\n                }\r\n            } else {\r\n                sprite.vy += sprite.gravity;\r\n\r\n                sprite.y += sprite.vy;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Called when the object reaches the ground: simply inverts velocity\r\n         * \r\n         * @private\r\n         */\r\n        resetY() {\r\n            this.sprite.vy = -this.sprite.vy * this.elasticity;\r\n        }\r\n    };\r\n\r\n    export default SimpleFall;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/SimpleFall.js","import Behavior from 'Object/Behavior/Behavior';\r\nimport Tile from 'Map/Tile';\r\n\r\n    /*jshint devel: true, bitwise: false*/\r\n    /**\r\n     * Simple behavior that moves horizontally until a wall is reached.\r\n     * \r\n     * @param {Sprite} sprite The sprite to attach the behavior to.\r\n     * @param {InputManager} Input A reference to the InputManager.\r\n     * @param {Object} options The options of the behavior\r\n     * @param {String} [options.direction=\"left\"] The initial direction of the move, default is `right`.\r\n     * \r\n     */\r\n    class WeaponMove extends Behavior{\r\n        constructor(sprite, Input, options) {\r\n            super(sprite, Input, options);\r\n\r\n            this.direction = options.direction || 'right';\r\n\r\n            if (this.direction.match('left')) {\r\n                sprite.vx = -sprite.vx;\r\n            }\r\n\r\n            if (this.direction.match('top')) {\r\n                sprite.vy = -sprite.vy;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * The onMove event handler, simply moves updates the object's x using vx and calls VXChange\r\n         * when it reaches a wall\r\n         */\r\n        onMove(t) {\r\n            let sprite = this.sprite,\r\n                map = sprite.currentMap,\r\n                nextX = sprite.x + sprite.vx,\r\n                nextY = sprite.y + sprite.vy,\r\n                hitBox = sprite.getHitBox(),\r\n                startX = sprite.vx > 0 ? hitBox.x2 : hitBox.x;\r\n\r\n            if (map.hitObjectTest(nextX + startX, nextY + hitBox.y, nextX + startX, nextY + hitBox.y2, Tile.TYPE.WALL)) {\r\n                sprite.vx = -sprite.vx;\r\n                if (this.onVXChange) {\r\n                    this.onVXChange(sprite.vx);\r\n                }\r\n            }\r\n\r\n            sprite.x += sprite.vx;\r\n            sprite.y += sprite.vy;\r\n        }\r\n    };\r\n\r\n    export default WeaponMove;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Behavior/WeaponMove.js","import GfxObject from 'Object/Object';\r\n\r\nexport default class Circle extends GfxObject{\r\n    constructor(options) {\r\n        super('circle', options);\r\n\r\n        this.w = options.w || 0;\r\n        this.h = options.h || 0;\r\n        this.x = options.x || this.w / 2;\r\n        this.y = options.y || this.h / 2;\r\n        this.radius = options.radius || this.w / 2;\r\n        this.color = options.color || \"red\";\r\n    }\r\n\r\n    draw(ctx, debug) {\r\n        ctx.beginPath();\r\n        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\r\n        ctx.fillStyle = this.color;\r\n        ctx.fill();\r\n    }\r\n};\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Circle.js","// define(['Sprite'], function() {\n  import Sprite from 'Object/Sprite';\n\t/*jshint devel: true, bitwise: false*/\n\t/*globals Class*/\n\tclass Hud {\n\t\tconstructor(options) {\n      // super(options);\n      \n\t\t\tthis.score = options.score || 0;\n\t\t\tthis.alertnateScore = options.alternateScore || 0;\n\t\t\tthis.energy = options.energy || 100;\n\t\t\tthis.$dest = options.target;\n\t\t\tthis.info = '';\n\t\t\tthis.inventory = {};\n\n\t\t\tthis.width = options.width || 1024;\n\t\t\tthis.height = options.height || 64;\n\n\t\t\tObject.defineProperty(this, \"score\", {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.score;\n\t\t\t\t},\n\n\t\t\t\tset: function(score) {\n\t\t\t\t\t// TODO: some checks\n\t\t\t\t\tthis.score = score;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n    \n\t\tdrawBackground() {\n\n\t\t}\n\t\t\n    draw() {\n\t\t\t// TODO\n\t\t\tthis.drawBackground();\n\t\t}\n\t}\n\n\texport default Hud;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Hud.js","import GfxObject from 'Object/Object';\nimport Text from 'Object/Text';\n\n\n\t/*jshint devel: true, bitwise: false*/\n    /**\n     * The menu class allows to quickly add text menu to an Athena Scene\n     * \n     * Each menu entry is called menuItem and is a simple object with the following properties:\n     * { text: 'menu text', selectable: true|false, active: true|false, visible: true|false }\n     * \n     * @param {String} type The type of object.\n     * @param {Object} options\n     * @param {String} [options.title=\"Menu Title\"] The title of the menu.\n     * @param {String} [options.color=\"black\"] The color of the menu.\n     * @param {Array} [options.menuItems=[]] The menu items to add.\n     * @param {String} [options.selectedColor=\"red\"] The default color to use for the selected menu item.\n     * \n     * @example\n     * \n     * let myMenu = new Menu('mainMenu', {\n     *   title: 'Gods JS',\n     *      color: 'white',\n     *      menuItems: [\n     *      {\n     *          text: '> Start Game',\n     *          selectable: true,\n     *          visible: true,\n     *          active: true\n     *      },\n     *      {\n     *          text: '> Cannot Select ;)',\n     *          selectable: true,\n     *          visible: true\n     *      }]\n     *    })\n     */\n    class Menu extends GfxObject{\n\t\tconstructor(type, options) {\n      \n      super(type, options);\n        // this.type = type;\n        // this.id = this.type + new Date().getTime();\n\n        this.title = new Text(type, {\n            color: options.color || 'black',\n            text: options.title || 'Menu Title'\n        });\n\n        this.color = options.color || 'white';\n        this.selectedColor = options.selectedColor || 'red';\n\n        this.menuItems = [];\n\n        this.selectedItem = options.selectedItem || 0;\n\n        this.selectCallbacks = [];\n        this.hoverCallbacks = [];\n\n        this.itemHeight = options.itemHeight || 40;\n\n        // SUPERHERE this._super(type, options);\n\n        this.title.moveTo(this.x, this.y);\n\n        this.addMenuItems(options.menuItems ||[]);\n    }\n\n    /**\n     * Adds a new menu item\n     * \n     * @param {Object} menu An hash describing the menu.\n     * The hash can have the following properties: \n     * { text: 'menu text', selectable: true|false, active: true|false, visible: true|false }\n     */\n    addMenuItem(menu) {\n      let y = this.y + ((this.menuItems.length + 1) * this.itemHeight),\n          menuItem = new Text('menuItem' + this.menuItems.length, menu);\n\n      menuItem.moveTo(this.x, y);\n      menuItem.visible = menu.visible === true || false;\n      menuItem.selectable = menu.selectable === true || false;\n    \n      this.menuItems.push(menuItem);\n    }\n\n    /**\n     * Adds several menuItems in a row\n     * \n     * @param {Array} items The list of items to add\n     * \n     * @see addMenuItem()\n     */\n    addMenuItems(items) {\n        console.log('addMenuItems', items);\n\n        items.forEach((item, idx) => {\n            this.addMenuItem(item);\n            if (item.active) {\n                this.selectedItem = idx;\n            }\n        });\n    }\n\n    /**\n     * Selects the next item in the item list\n     * \n     * @private\n     */\n    nextItem() {\n        if (++this.selectedItem >= this.menuItems.length) {\n            this.selectedItem = 0;\n        }\n\n        if (this.selectedItem && this.menuItems[this.selectedItem] && !this.menuItems[this.selectedItem].selectable) {\n            this.nextItem();\n        }\n    }\n\n    /**\n     * Returns the index of the selected item\n     * \n     * @returns {Number} The index of the selected item.\n     * \n     * @private\n     */\n    getSelectedItemIndex() {\n        return this.selectedItem;\n    }\n\n    /**\n     * Returns the current selected Item object\n     * \n     * @returns {Object} Current selected item.\n     * \n     * @private\n     */\n    getSelectedItem() {\n        return this.menuItems[this.selectedItem];\n    }\n\n    /**\n     * Updates the text of a menu item\n     * \n     * @param {Number} itemId The index of the item to modify.\n     * @param {String} text The new text.\n     * \n     */\n    setText(itemId, text) {\n        this.menuItems[itemId] = text;\n    }\n\n    /**\n     * Draw method for the Text object\n     * \n     * @param {CanvasContext} destCtx The canvas context where to draw the menu\n     * \n     * @private\n     */\n    draw(destCtx) {\n        if (this.angle !== 0) {\n            destCtx.save();\n            destCtx.rotate(this.angle);\n        }\n\n        this.title.draw(destCtx);\n\n        this.menuItems.forEach((menuItem, idx) => {\n            if (idx === this.selectedItem) {\n                menuItem.color = this.selectedColor || 'blue';\n            } else {\n                menuItem.color = this.color;\n            }\n            menuItem.draw(destCtx);\n        });\n\n        if (this.angle !== 0) {\n            destCtx.restore();\n        }\n    }\n};\n\nexport default Menu;\n\n\n\n// WEBPACK FOOTER //\n// ./js/Object/Menu.js","import ResourceManager from 'Resource/ResourceManager';\r\nimport Sprite from 'Object/Sprite';\r\nimport BitmapText from 'Object/BitmapText';\r\nimport Text from 'Object/Text';\r\nimport Map from 'Map/Map';\r\nimport Tile from 'Map/Tile';\r\nimport NM from 'Notification/NotificationManager';\r\n\r\nimport Deferred from 'Core/Deferred';\r\n/*jshint devel: true, bitwise: false*/\r\n// debug\r\nwindow.scenes = {};\r\n\r\n/**\r\n * The `Scene` is used to display your objects. In AthenaJS you first add objects onto the scene.\r\n * When you scene is rendered (at 60fps), your objects appear on the screen.\r\n * \r\n * Instead of creating a new scene, it is common to extend the Scene class to create your own scene.\r\n * \r\n * @param {Object} options\r\n * @param {string} [options.name=\"Scene\"+timestamp] The name of your scene.\r\n * @param {Object} [options.resources] An optional array of resources of the form: ``{ id: 'unique id', type: 'image|script|map|audio', src: 'path_to_resource'}`` that the scene needs.\r\n * @param {number} [options.backgrounds=1] The number of backgrounds: a scene can have any number of backgrounds.\r\n * @param {number} [options.layers=2] The number of layers: layers are stacked above the backgrounds.\r\n * @param {number} [options.foregrounds=1] The number of foreground layers. This would typically be used for parallax scrollings.\r\n * @param {number} [options.opacity=1] The default opacity for the scene: can be usefull to have fadeIn effects when starting the scene.\r\n * @param {number} [options.hudScene] Scenes can have an option `hud` scene that is automatically rendered on top of it. This allows to easily add score/status elements to games.\r\n * \r\n */\r\nclass Scene {\r\n    constructor(options) {\r\n        options = options || {};\r\n\r\n        console.log('[scene ' + options.name || '' + '] ' + 'Init()', options);\r\n\r\n        // we may have several backgrounds\r\n        this.backgrounds = new Array(options.backgrounds || 1);\r\n\r\n        this.layers = new Array(options.layers || 2);\r\n\r\n        // foregrounds will be added later\r\n        this.foregrounds = new Array(options.backgrounds || 1);\r\n\r\n        this.readyDef = null;\r\n\r\n        this.resources = options.resources || null;\r\n\r\n        this.pics = {};\r\n\r\n        this.map = null;\r\n\r\n        this.loaded = false;\r\n\r\n        this.running = false;\r\n\r\n        this.backgroundImage = null;\r\n\r\n        this.name = options.name || `Scene${new Date().getTime()}`;\r\n\r\n        this.opacity = (typeof options.opacity !== 'undefined') ? options.opacity : 1;\r\n\r\n        this.hudScene = options.hudScene || null;\r\n\r\n        // will hold the time of gameplay\r\n        this.time = null;\r\n        this.playTime = null;\r\n\r\n        // debug\r\n        window.scenes[this.name] = this;\r\n\r\n        this._startCallbacks = [];\r\n\r\n        this._fillArrays();\r\n\r\n    }\r\n    /**\r\n     * Browsers seem to do some conversion the first time drawImage is used from/to canvas\r\n     * \r\n     * @see [Optimising the canvas element](http://www.warpdesign.fr/my-experience-optimising-the-canvas-html5-element/)\r\n     * @private\r\n     * \r\n     */\r\n    _prepareCanvas() {\r\n        if (this.resources) {\r\n            this.display.prepareCanvas(this.resources);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill layers arrays\r\n     * @private\r\n     */\r\n    _fillArrays() {\r\n        for (let i = 0; i < this.layers.length; ++i) {\r\n            this.layers[i] = [];\r\n        }\r\n\r\n        for (let i = 0; i < this.backgrounds.length; ++i) {\r\n            this.backgrounds[i] = [];\r\n        }\r\n        for (let i = 0; i < this.foregrounds.length; ++i) {\r\n            this.foregrounds[i] = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save references of loaded resources for later use\r\n     * @private\r\n     */\r\n    _getResourcesRef() {\r\n        let resources = this.resources;\r\n\r\n        if (resources) {\r\n            resources.forEach(function (res) {\r\n                res.elt = ResourceManager.getResourceById(res.id);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads resources\r\n     * \r\n     * @param {array} res An array of resources to load.\r\n     * @param {function} [progressCb=undefined] A progress callback function that gets called after each resource has been loaded\r\n     * @returns {Deferred} `this.readyDef`\r\n     * @private\r\n     * \r\n     */\r\n    loadResources(res, progressCb/*, doneCb, failCb*/) {\r\n        console.log('[scene ' + this.name + '] ' + 'loading Resources...');\r\n\r\n        if (!this.loaded) {\r\n            console.log('[scene ' + this.name + '] ' + ' seems like the scene needs to be loaded: goooo!');\r\n            this.readyDef = ResourceManager.addResources(res);\r\n\r\n            // add the huds resources as well\r\n            // if (this.hudScene && !this.hudScene.loaded) {\r\n            //     this.readyDef = ResourceManager.addResources(this.hudScene.resources);\r\n            // }\r\n\r\n            this.readyDef.then(() => {\r\n                // if (this.hudScene) {\r\n                //     this.hudScene.load();\r\n                // }\r\n                this.loaded = true;\r\n            });\r\n\r\n            this.readyDef.then(this.cacheImages.bind(this));\r\n            this.readyDef.then(this.onLoad.bind(this));\r\n\r\n            ResourceManager.loadResources('any', progressCb);\r\n        } else {\r\n            console.log('[scene ' + this.name + '] ' + ' seems like the scene has already been loaded: good!');\r\n            // this.onLoad();\r\n        }\r\n\r\n        return this.readyDef;\r\n    }\r\n\r\n    /**\r\n     * Loads the scene (if needed)\r\n     * @private\r\n     */\r\n    load() {\r\n        console.log('[Scene ' + this.name + '] load()');\r\n        if (this.hudScene && !this.hudScene.loaded) {\r\n            let def = new Deferred();\r\n            this.hudScene.load().then(() => {\r\n                this.loadResources(this.resources).then(() => {\r\n                    debugger;\r\n                    def.resolve();\r\n                })\r\n            });\r\n\r\n            return def.promise;\r\n        } else {\r\n            return this.loadResources(this.resources);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple debug method: this be redefined for specific games\r\n     */\r\n    debug() {\r\n        console.log('[scene ' + this.name + '] ' + 'debug() default scene debug does nothing!');\r\n    }\r\n\r\n    /**\r\n     * This method is called once resources have been loaded and does the following:\r\n     * 1. creates layer arrays\r\n     * 2. get reference resources from the resourceManager\r\n     * 3. prepare canvas elements\r\n     */\r\n    onLoad() {\r\n        this._fillArrays();\r\n        this._getResourcesRef();\r\n        this._prepareCanvas();\r\n    }\r\n\r\n    onStart(cb) {\r\n        this._startCallbacks.push(cb.bind(this));\r\n        if (this.running) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a reference of each `image` resource that has been loaded.\r\n     * \r\n     * @private\r\n     */\r\n    cacheImages() {\r\n        console.log('[scene ' + this.name + '] ' + ' caching Images');\r\n        // var max = this.resources.length,\r\n        //     i,\r\n        //     id;\r\n        if (!this.resources) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            for (let i = 0, max = this.resources.length; i < max; i++) {\r\n                let id = this.resources[i].id;\r\n                if (this.resources[i].type === 'image') {\r\n                    this.pics[id] = ResourceManager.getResourceById(id);\r\n                }\r\n            }\r\n        } catch (err) {\r\n            debugger;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the specified map with the scene: the map will then be used to render the scene.\r\n     * *note* The map can either be an instance of a Map or a class inheriting from Map, in which case\r\n     * \r\n     * @param {Map|Object} map The `Map` to use: it can be an instance of a Map inheriting class or\r\n     * an options Object that will be used to create a new {Map} instance\r\n     * \r\n     */\r\n    setMap(map) {\r\n        if (map instanceof Map) {\r\n            this.map = map;\r\n        } else {\r\n            this.map = new Map(map);\r\n        }\r\n        // debug stuff\r\n        window.currentMap = this.map;\r\n    }\r\n\r\n    /**\r\n     * Add one ore more display objects onto the scene\r\n     * \r\n     * @param {Array|GfxObject} objects The object(s) to add onto the scene.\r\n     * @param {string} [layerType=\"front\"] Defines in which type of layer the object should be added.\r\n     * @param {number} [layerNum=0] Defines the layer number where to add the objects.\r\n     */\r\n    addObject(objects, layerType, layerNum) {\r\n        console.log('[scene ' + this.name + '] ' + 'addObject', objects, layerType, layerNum);\r\n        // var layer = null,\r\n        //     that = this;\r\n\r\n        let type = layerType || 'front',\r\n            num = layerNum || 0,\r\n            layer = null;\r\n\r\n        switch (type) {\r\n            case 'back':\r\n                layer = this.backgrounds[num];\r\n                break;\r\n\r\n            case 'fore':\r\n                layer = this.foregrounds[num];\r\n                break;\r\n\r\n            default:\r\n            case 'front':\r\n                layer = this.layers[num];\r\n                break;\r\n        }\r\n\r\n        // console.log('[scene ' + this.name + '] ' + layerNum, layerType, layer, this.layers);\r\n\r\n        debugger;\r\n        if (Array.isArray(objects)) {\r\n            for (let obj of objects) {\r\n                console.log('[scene ' + this.name + '] ' + 'pushing', obj);\r\n                layer.push(obj);\r\n                if (typeof obj.setImage === 'function') {\r\n                    obj.setImage(this.pics[obj.imageSrc]);\r\n                }\r\n                obj.setScene(this);\r\n            }\r\n        } else {\r\n            layer.push(objects);\r\n            if (typeof objects.setImage === 'function') {\r\n                objects.setImage(this.pics[objects.imageSrc]);\r\n            }\r\n            objects.setScene(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the associated map into the specified canvas context\r\n     * \r\n     * @param {CanvasContext} destCtx The canvas context where the map should be rendered.\r\n     * \r\n     * @private\r\n     */\r\n    drawMap(destCtx) {\r\n        if (!this.map.isDirty) {\r\n            return;\r\n        }\r\n\r\n        this.display.clearScreen(destCtx);\r\n        this.map.draw(destCtx, false);\r\n    }\r\n\r\n    /**\r\n     * Draws every object that is part of the associated map\r\n     * \r\n     * @param {CanvasContext} destCtx The canvas context where the map should be rendered.\r\n     * \r\n     * @private\r\n     */\r\n    drawMapObjects(destCtx) {\r\n        console.log('drawObjects');\r\n        this.map.drawObjects(destCtx);\r\n    }\r\n\r\n    /**\r\n     * Draws every object that has been added onto the scene\r\n     * \r\n     * @param {CanvasContext} destCtx The canvas context where the map should be rendered.\r\n     * \r\n     * @private\r\n     */\r\n    drawSceneObjects(destCtx) {\r\n        // var i, j,\r\n        //     max, max2,\r\n        //     obj = null,\r\n        //     layer = null;\r\n\r\n        // i = j = max = max2 = 0;\r\n        // got through the list of all objects and render them if they are visible ?\r\n        for (let i = 0, max = this.layers.length; i < max; i++) {\r\n            let layer = this.layers[i];\r\n            for (let j = 0, max2 = layer.length; j < max2; j++) {\r\n                let obj = layer[j];\r\n                obj.draw(destCtx);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method calls the move() callback of each object that has been placed onto the map.\r\n     * \r\n     * It is automatically called by the run method after each frame.\r\n     * \r\n     * @private\r\n     */\r\n    moveSceneObjects() {\r\n        // var i, j,\r\n        //     max, max2,\r\n        //     obj = null,\r\n        //     layer = null;\r\n\r\n        // i = j = max = max2 = 0;\r\n\r\n        // got through the list of all objects and call move method ?\r\n        for (let i = 0, max = this.layers.length; i < max; i++) {\r\n            let layer = this.layers[i];\r\n            for (let j = 0, max2 = layer.length; j < max2; j++) {\r\n                let obj = layer[j];\r\n                obj.move();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes the opacity of the scene\r\n     * \r\n     * @param {number} opacity The new opacity.\r\n     */\r\n    setOpacity(opacity) {\r\n        this.opacity = opacity;\r\n    }\r\n\r\n    /**\r\n     * Returns the current opacity of the scene\r\n     * \r\n     * @returns {number} The current opacity value.\r\n     */\r\n    getOpacity() {\r\n        return this.opacity;\r\n    }\r\n\r\n    /**\r\n     * You can set a static background image independently of the layers/\r\n     * \r\n     * @param {Image|String} The image to set as background\r\n     * @obsolete\r\n     */\r\n    setBackgroundImage(image) {\r\n        this.backgroundImage = image;\r\n        // todo: hardcoded for now\r\n        if (image instanceof Image) {\r\n            new Dom('.main').css('backgroundImage', 'url(' + image.src + ')');\r\n        } else {\r\n            new Dom('.main').css('backgroundImage', 'url(' + image + ')');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume the scene playback\r\n     */\r\n    resume() {\r\n        this.start(true);\r\n    }\r\n\r\n    /**\r\n     * Starts the scene\r\n     * \r\n     * @param {boolean} [doNotResetMap=false] set to false if you don't want the map associated with the scene to have\r\n     * its objects reset. This is useful when pausing the game for example.\r\n     */\r\n    start(doNotResetMap) {\r\n        if (!this.loaded) {\r\n            console.warn('[Scene] start() attempt to start a scene that has not been loaded yet. Start failed.');\r\n        }\r\n\r\n        this.running = true;\r\n\r\n        if (this.map) {\r\n            if (!doNotResetMap)\r\n                this.map.reset();\r\n            else\r\n                this.map.resume();\r\n\r\n            // force render of the map in any way\r\n            this.map.isDirty = true;\r\n        }\r\n\r\n        // reset layers too\r\n        this.backgrounds.length = 0;\r\n\r\n        this.layers.forEach((layer) => {\r\n            layer.length = 0;\r\n        });\r\n\r\n        // be sure to clear all canvas, inc. secondary, especially\r\n        // if we go from a scene with an hud, to a scene without one\r\n        this.display.clearAllScreens();\r\n\r\n        this.foregrounds.length = 0;\r\n\r\n        this.time = new Date().getTime();\r\n\r\n        this.playTime = null;\r\n\r\n        if (this.hudScene) {\r\n            this.hudScene.start();\r\n        }\r\n\r\n        this._startCallbacks.forEach((cb) => {\r\n            cb();\r\n        });\r\n    }\r\n\r\n    /***\r\n     * stop the scene: TODO MERGE\r\n     */\r\n    stop() {\r\n        this.running = false;\r\n\r\n        if (this.hudScene) {\r\n            this.hudScene.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * pause the scene: TODO MERGE\r\n     */\r\n    pause() {\r\n        this.running = false;\r\n        this.playTime = new Date().getTime() - this.time;\r\n        console.log('pausing, playTime = ', this.playTime / 1000);\r\n\r\n        if (this.hudScene) {\r\n            this.hudScene.pause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * unpause the scene: TODO MERGE\r\n     */\r\n    unpause() {\r\n        this.running = true;\r\n        this.time = new Date().getTime() - this.playTime;\r\n        console.log('resuming, playTime = ', (this.playTime / 1000));\r\n        this.playTime = null;\r\n\r\n        if (this.hudScene) {\r\n            this.hudScene.unpause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the total playtime\r\n     * \r\n     * @returns {number} the total playtime in milliseconds\r\n     */\r\n    getPlayTime() {\r\n        let playTime = null;\r\n\r\n        if (this.playTime) {\r\n            playTime = this.playTime;\r\n        } else {\r\n            playTime = new Date().getTime() - this.time;\r\n        }\r\n\r\n        return playTime / 1000;\r\n    }\r\n\r\n    /**\r\n     * The run loop is where scene elements are moved and collisions are checked.\r\n     * \r\n     * The map, if there is one, is also updated here (viewport, new objects, etc)\r\n     */\r\n    run() {\r\n        this.moveSceneObjects();\r\n\r\n        // user-loop: put user interaction here\r\n        // move map, and sprites found onto the map\r\n        if (this.map) {\r\n            this.map.move();\r\n            this.map.checkCollisions();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is responsible for drawing the scene and will be called 60 times a second.\r\n     * \r\n     * @param {Array} layers The layers array to draw.\r\n     * *note* When the scene is not running, this method isn't called at all.\r\n     */\r\n    render(layers) {\r\n        // render-loop: put render-related stuff here\r\n        if (this.map) {\r\n            this.drawMap(layers[0]);\r\n            this.drawMapObjects(layers[1]);\r\n        }\r\n\r\n        this.drawSceneObjects(layers[1]);\r\n    }\r\n\r\n    /**\r\n     * Notify the scene of an event\r\n     * \r\n     * @param {string} eventType The type of event to trigger.\r\n     * @param {any} data The data (if any) associated with the event.\r\n     */\r\n    notify(eventType, data) {\r\n        NM.notify(eventType, data);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to a list of events\r\n     * \r\n     * @param {String} eventList The list of events to subscribe to as a space separated string.\r\n     */\r\n    bindEvents(eventList) {\r\n        NM.listen(eventList, this.onEvent.bind(this));\r\n    }\r\n\r\n    /**\r\n     * onEvent is called once one of the registered events has been triggered\r\n     */\r\n    onEvent() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Attach the specified display to the scene\r\n     * \r\n     * @param {Display} display The display to attach the scene to.\r\n     */\r\n    setDisplay(display) {\r\n        this.display = display;\r\n\r\n        if (this.hudScene) {\r\n            this.hudScene.setDisplay(display);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the specified effect to the scene\r\n     * \r\n     * @param {String} fxName The name of the effect to apply.\r\n     * @param {Object} options The options of the effect.\r\n     */\r\n    animate(fxName, options) {\r\n        return this.display.animate(fxName, options, this);\r\n    }\r\n\r\n    /**\r\n     * Remove the specified object from the scene\r\n     * \r\n     * @param {GfxObject} gfxObject the object to remove from the scene\r\n     */\r\n    removeObject(gfxObject) {\r\n        let layer = this.layers[0],\r\n            foundIndex = layer.indexOf(gfxObject);\r\n\r\n        if (foundIndex > -1) {\r\n            layer.splice(foundIndex, 1);\r\n        }\r\n    }\r\n};\r\n\r\nexport default Scene;\n\n\n// WEBPACK FOOTER //\n// ./js/Scene/Scene.js","/*\n * fpscounter.js\n *\n * A simple in-browser fps counter, suitable for using with a bookmarklet\n * \n * @author Pete Otaqui <pete@otaqui.com>\n * @url https://github.com/pete-otaqui/fpscounter\n * @license Creative Commons Attribution 3.0 Unported\n * @license http://creativecommons.org/licenses/by/3.0/deed.en_GB\n*/\n(function(global) {\n    global.fpscounter = function(options) {\n        // late binding for options > global.fpscounter_options > defaults\n        options = options || {};\n        var globals = global.fpscounter_options || {};        \n\n        var defaults = {\n            remove_on_click: false,\n            width: 100,\n            height: 50\n        };\n        Object.keys(defaults).forEach(function(key) {\n            options[key] = options[key] || globals[key] || defaults[key];\n        });\n\n\n        // get the width height for repeated use\n        var canvas_w = options.width,\n            canvas_h = options.height;\n\n        // create the new dom elements, the canvas context, the style\n        var ele = document.createElement('div');\n        ele.className = 'fpscounter';\n        ele.style.width = canvas_w + 'px';\n        ele.style.height = canvas_h + 'px';\n\n        var canvas = document.createElement('canvas');\n        canvas.className = 'fpscounter-canvas';\n        canvas.width = canvas_w;\n        canvas.height = canvas_h;\n\n        var context = canvas.getContext('2d'),\n            text_fps_x = canvas_w/2 - 14,\n            text_fps_y = canvas_h/2 + 10,\n            text_max_x = 4,\n            text_max_y = 8,\n            text_min_x = 4,\n            text_min_y = canvas_h - 4,\n            fps_font = 'bold 30px Monospace',\n            min_max_font = '10px Monospace';\n\n        var gradient_fill = context.createLinearGradient(0,0,0,canvas_h);\n        gradient_fill.addColorStop(0, '#001133');\n        gradient_fill.addColorStop(1, '#112288');\n\n        var gradient_line = context.createLinearGradient(0,0,0,canvas_h);\n        gradient_line.addColorStop(0, '#2848d8');\n        gradient_line.addColorStop(1, '#3366ff');\n\n        context.lineWidth = 1;\n        context.strokeStyle = gradient_line;\n\n\n        var style = document.createElement('style');\n        style.textContent = '.fpscounter { '+\n                                'position: fixed; '+\n                                'top: 0; '+\n                                'right: 0; '+\n                                'background-color: #000; '+\n                                'color: #fff; '+\n                                'font-size: 30px; '+\n                                'font-family: monospace;'+\n                                'z-index: 999999'+\n                            '}';\n\n        ele.appendChild(canvas);\n        document.body.appendChild(ele);\n        document.querySelector('head').appendChild(style);\n\n\n        // initialize some timing and history variables\n        var t_pre, t_now, u_pre, u_lim,\n            h_arr = [], h_len = canvas_w,\n            raf_request, raf_running;\n\n        // we won't update anything more often than this many milliseconds\n        u_lim = 100;\n\n        // reduce an array of values to it members bounding values in the form [min, max]\n        function h_reduce(memo, item) {\n            if ( !memo[0] || item < memo[0]) memo[0] = item;\n            if ( !memo[1] || item > memo[1]) memo[1] = item;\n            return memo;\n        }\n\n        function checkfps() {\n            var fps, c_min_max, c_min, c_max, c_delta, first_point, xy;\n            raf_running = true;\n            t_now = Date.now();\n            // this is where we throttle displayed updates\n            if ( t_now >= u_pre + u_lim) {\n\n                // get the fps for the history\n                fps = Math.min(60, Math.round(1/(t_now-t_pre)*1000));\n                h_arr.unshift(fps);\n\n                // do required math\n                context.clearRect(0, 0, canvas_w, canvas_h);\n                if ( h_arr.length > h_len ) h_arr.pop();\n                c_min_max = h_arr.reduce(h_reduce, []);\n                c_min = c_min_max[0];\n                c_max = c_min_max[1];\n                c_delta = c_max - c_min;\n\n\n                // draw the line graph\n                context.fillStyle = gradient_fill;\n                context.beginPath();\n                // first_point = fpsToPoint(0, h_arr[0], c_min, c_delta);\n                context.moveTo(canvas_w, canvas_h);\n                h_arr.forEach(function(fps_val, index) {\n                    xy = fpsToPoint(index, fps_val, c_min, c_delta);\n                    context.lineTo(xy[0], xy[1]);\n                });\n                context.lineTo(xy[0], canvas_h);\n                context.lineTo(canvas_w, canvas_h);\n                context.fill();\n                context.stroke();\n\n                context.fillStyle = '#fff';\n                // write the main FPS text\n                context.font = fps_font;\n                context.fillText(fps, text_fps_x, text_fps_y);\n\n                // write the limit texts\n                context.font = min_max_font;\n                context.fillText(c_min, text_min_x, text_min_y);\n                context.fillText(c_max, text_max_x, text_max_y);\n\n                // set the \"update time\" counter\n                u_pre = t_now;\n            }\n\n            // set the \"frame time\" counter\n            t_pre = t_now;\n\n            // request another update later\n            if ( raf_running ) {\n                raf_request = requestAnimationFrame(checkfps);\n            }\n        }\n\n        // convert an fps value to an [x,y] array\n        function fpsToPoint(index, fps_val, min, delta) {\n            return [\n                canvas_w - index,\n                canvas_h - canvas_h * (fps_val - min) / delta\n            ];\n        }\n\n        // add removal event\n        ele.addEventListener('click', function() {\n            raf_running = !raf_running;\n            if (raf_running) {\n                start();\n            } else {\n                cancelAnimationFrame(raf_request);\n                if ( options.remove_on_click ) {\n                    document.body.removeChild(ele);\n                }\n            }\n        });\n\n        // start\n        function start() {\n            t_pre = Date.now();\n            h_arr = [];\n            u_pre = t_pre;\n            checkfps();\n        }\n\n        start();\n    };\n\n    // lots of negatives here because the assumption is we should start\n    if ( !global.fpscounter_options || global.fpscounter_options.auto_start !== false) {\n        // global.fpscounter();\n    }\n\n})(window);\n\n\n// WEBPACK FOOTER //\n// ./js/lib/fpscounter/fpscounter.min.js"],"sourceRoot":""}